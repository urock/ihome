###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/Sep/2014  17:06:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Libraries\STM32F2x7_ETH_Driver\src\stm32f2x7_eth.c
#    Command line =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Libraries\STM32F2x7_ETH_Driver\src\stm32f2x7_eth.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM322xG_EVAL -lcN
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\
#        -o
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2x7_ETH_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM322xG_EVAL\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\lwip\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\netif\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\ipv4\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\FreeRTOS\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\portable\IAR\ARM_CM3\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\include\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\stm32f2x7_eth.lst
#    Object file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\stm32f2x7_eth.o
#
###############################################################################

C:\ihome\MCU\STM\trunk\mcu_main\IAR\Libraries\STM32F2x7_ETH_Driver\src\stm32f2x7_eth.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2x7_eth.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-April-2011
      7            * @brief   This file is the low level driver for STM32F2x7 Ethernet Controller.
      8            *          This driver does not include low level functions for PTP time-stamp.            
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************
     21            */
     22          
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm32f2x7_eth.h"
     25          #include "stm32f2xx_rcc.h"
     26          #include <string.h>
     27          
     28          /** @addtogroup STM32F2x7_ETH_Driver
     29            * @brief ETH driver modules
     30            * @{
     31            */
     32          
     33          /** @defgroup ETH_Private_TypesDefinitions
     34            * @{
     35            */ 
     36          /**
     37            * @}
     38            */ 
     39          
     40          
     41          /** @defgroup ETH_Private_Defines
     42            * @{
     43            */ 
     44          
     45          /**
     46            * @}
     47            */
     48          
     49          /** @defgroup ETH_Private_Macros
     50            * @{
     51            */ 
     52          /**
     53            * @}
     54            */
     55          
     56          /** @defgroup ETH_Private_Variables
     57            * @{
     58            */ 
     59          
     60          #if defined   (__CC_ARM) /*!< ARM Compiler */
     61            __align(4) 
     62             ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
     63            __align(4) 
     64             ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
     65            __align(4) 
     66             uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
     67            __align(4) 
     68             uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
     69          
     70          #elif defined ( __ICCARM__ ) /*!< IAR Compiler */
     71            #pragma data_alignment=4
     72             ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
     73            #pragma data_alignment=4
     74             ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
     75            #pragma data_alignment=4
     76             uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
     77            #pragma data_alignment=4
     78             uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
     79          
     80          #elif defined (__GNUC__) /*!< GNU Compiler */
     81            ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__ ((aligned (4))); /* Ethernet Rx DMA Descriptor */
     82            ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__ ((aligned (4))); /* Ethernet Tx DMA Descriptor */
     83            uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__ ((aligned (4))); /* Ethernet Receive Buffer */
     84            uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__ ((aligned (4))); /* Ethernet Transmit Buffer */
     85          
     86          #elif defined  (__TASKING__) /*!< TASKING Compiler */                           
     87            __align(4) 
     88             ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
     89            __align(4) 
     90             ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
     91            __align(4) 
     92             uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
     93            __align(4) 
     94             uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
     95          
     96          #endif /* __CC_ARM */
     97          
     98          
     99          /* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */
    100          __IO ETH_DMADESCTypeDef  *DMATxDescToSet;
    101          __IO ETH_DMADESCTypeDef  *DMARxDescToGet;
    102          
    103          
    104          /* Structure used to hold the last received packet descriptors info */
    105          
    106          ETH_DMA_Rx_Frame_infos RX_Frame_Descriptor;
    107          __IO ETH_DMA_Rx_Frame_infos *DMA_RX_FRAME_infos;
    108          __IO uint32_t Frame_Rx_index;
    109          
    110          
    111          /**
    112            * @}
    113            */
    114          
    115          /** @defgroup ETH_Private_FunctionPrototypes
    116            * @{
    117            */ 
    118          /**
    119            * @}
    120            */
    121          
    122          /** @defgroup ETH_Private_Functions
    123            * @{
    124            */
    125          
    126          #ifndef USE_Delay
    127          /**
    128            * @brief  Inserts a delay time.
    129            * @param  nCount: specifies the delay time length.
    130            * @retval None
    131            */
    132          static void ETH_Delay(__IO uint32_t nCount)
    133          {
    134            __IO uint32_t index = 0; 
    135            for(index = nCount; index != 0; index--)
    136            {
    137            }
    138          }
    139          #endif /* USE_Delay*/
    140          
    141          
    142          
    143          /******************************************************************************/                             
    144          /*                           Global ETH MAC/DMA functions                     */
    145          /******************************************************************************/
    146          
    147          /**
    148            * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
    149            * @param  None 
    150            * @retval None
    151            */
    152          void ETH_DeInit(void)
    153          {
    154            RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
    155            RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
    156          }
    157          
    158          
    159          /**
    160            * @brief  Fills each ETH_InitStruct member with its default value.
    161            * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
    162            * @retval None
    163            */
    164          void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
    165          {
    166            /* ETH_InitStruct members default value */
    167            /*------------------------   MAC Configuration   ---------------------------*/
    168            
    169            /* PHY Auto-negotiation enabled */
    170            ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
    171            /* MAC watchdog enabled: cuts-off long frame */
    172            ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
    173            /* MAC Jabber enabled in Half-duplex mode */
    174            ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                       
    175            /* Ethernet interframe gap set to 96 bits */
    176            ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
    177            /* Carrier Sense Enabled in Half-Duplex mode */ 
    178            ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
    179            /* PHY speed configured to 100Mbit/s */
    180            ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
    181            /* Receive own Frames in Half-Duplex mode enabled */
    182            ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
    183            /* MAC MII loopback disabled */ 
    184            ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
    185            /* Full-Duplex mode selected */
    186            ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
    187            /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
    188            ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                             
    189            /* Retry Transmission enabled for half-duplex mode */ 
    190            ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                   
    191            /* Automatic PAD/CRC strip disabled*/
    192            ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                          
    193            /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
    194            ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     
    195            /* half-duplex mode Deferral check disabled */
    196            ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
    197            /* Receive all frames disabled */ 
    198            ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
    199            /* Source address filtering (on the optional MAC addresses) disabled */
    200            ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
    201            /* Do not forward control frames that do not pass the address filtering */
    202            ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
    203            /* Disable reception of Broadcast frames */
    204            ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
    205            /* Normal Destination address filtering (not reverse addressing) */
    206            ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
    207            /* Promiscuous address filtering mode disabled */
    208            ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
    209            /* Perfect address filtering for multicast addresses */
    210            ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;       
    211            /* Perfect address filtering for unicast addresses */
    212            ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
    213            /* Initialize hash table high and low regs */
    214            ETH_InitStruct->ETH_HashTableHigh = 0x0;                
    215            ETH_InitStruct->ETH_HashTableLow = 0x0;                     
    216            /* Flow control config (flow control disabled)*/
    217            ETH_InitStruct->ETH_PauseTime = 0x0;                 
    218            ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
    219            ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
    220            ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
    221            ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
    222            ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
    223            /* VLANtag config (VLAN field not checked) */
    224            ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
    225            ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
    226            
    227            /*---------------------- DMA Configuration   -------------------------------*/
    228          
    229            /* Drops frames with with TCP/IP checksum errors */
    230            ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
    231            /* Store and forward mode enabled for receive */
    232            ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
    233            /* Flush received frame that created FIFO overflow */
    234            ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
    235            /* Store and forward mode enabled for transmit */
    236            ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
    237            /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
    238            ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
    239            /* Disable forwarding frames with errors (short frames, CRC,...)*/
    240            ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; 
    241            /* Disable undersized good frames */
    242            ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
    243            /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
    244            ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;                             
    245            /* Disable Operate on second frame (transmit a second frame to FIFO without 
    246            waiting status of previous frame*/                           
    247            ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
    248            /* DMA works on 32-bit aligned start source and destinations addresses */
    249            ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
    250            /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
    251            ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
    252            /* DMA transfer max burst length = 32 beats = 32 x 32bits */
    253            ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
    254            ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
    255            /* DMA Ring mode skip length = 0 */
    256            ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
    257            /* Equal priority (round-robin) between transmit and receive DMA engines */
    258            ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
    259          }
    260          
    261          
    262          /**
    263            * @brief  Initializes the ETHERNET peripheral according to the specified
    264            *   parameters in the ETH_InitStruct .
    265            * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains
    266            *   the configuration information for the specified ETHERNET peripheral.
    267            * @param PHYAddress: external PHY address                    
    268            * @retval ETH_ERROR: Ethernet initialization failed
    269            *         ETH_SUCCESS: Ethernet successfully initialized                 
    270            */
    271          uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
    272          {
    273            uint32_t RegValue = 0, tmpreg = 0;
    274            __IO uint32_t i = 0;
    275            RCC_ClocksTypeDef  rcc_clocks;
    276            uint32_t hclk = 60000000;
    277            __IO uint32_t timeout = 0;
    278            /* Check the parameters */
    279            /* MAC --------------------------*/ 
    280            assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct->ETH_AutoNegotiation));
    281            assert_param(IS_ETH_WATCHDOG(ETH_InitStruct->ETH_Watchdog));
    282            assert_param(IS_ETH_JABBER(ETH_InitStruct->ETH_Jabber));
    283            assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct->ETH_InterFrameGap));
    284            assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct->ETH_CarrierSense));
    285            assert_param(IS_ETH_SPEED(ETH_InitStruct->ETH_Speed));
    286            assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct->ETH_ReceiveOwn));
    287            assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct->ETH_LoopbackMode));
    288            assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct->ETH_Mode));
    289            assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct->ETH_ChecksumOffload));
    290            assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct->ETH_RetryTransmission));
    291            assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct->ETH_AutomaticPadCRCStrip));
    292            assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct->ETH_BackOffLimit));
    293            assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct->ETH_DeferralCheck));
    294            assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct->ETH_ReceiveAll));
    295            assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct->ETH_SourceAddrFilter));
    296            assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct->ETH_PassControlFrames));
    297            assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct->ETH_BroadcastFramesReception));
    298            assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct->ETH_DestinationAddrFilter));
    299            assert_param(IS_ETH_PROMISCIOUS_MODE(ETH_InitStruct->ETH_PromiscuousMode));
    300            assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct->ETH_MulticastFramesFilter));  
    301            assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct->ETH_UnicastFramesFilter));
    302            assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct->ETH_PauseTime));
    303            assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct->ETH_ZeroQuantaPause));
    304            assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct->ETH_PauseLowThreshold));
    305            assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct->ETH_UnicastPauseFrameDetect));
    306            assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct->ETH_ReceiveFlowControl));
    307            assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct->ETH_TransmitFlowControl));
    308            assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct->ETH_VLANTagComparison));
    309            assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct->ETH_VLANTagIdentifier));
    310            /* DMA --------------------------*/
    311            assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame));
    312            assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct->ETH_ReceiveStoreForward));
    313            assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct->ETH_FlushReceivedFrame));
    314            assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct->ETH_TransmitStoreForward));
    315            assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct->ETH_TransmitThresholdControl));
    316            assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct->ETH_ForwardErrorFrames));
    317            assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct->ETH_ForwardUndersizedGoodFrames));
    318            assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct->ETH_ReceiveThresholdControl));
    319            assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct->ETH_SecondFrameOperate));
    320            assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct->ETH_AddressAlignedBeats));
    321            assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct->ETH_FixedBurst));
    322            assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct->ETH_RxDMABurstLength));
    323            assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct->ETH_TxDMABurstLength)); 
    324            assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
    325            assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
    326            /*-------------------------------- MAC Config ------------------------------*/   
    327            /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
    328            /* Get the ETHERNET MACMIIAR value */
    329            tmpreg = ETH->MACMIIAR;
    330            /* Clear CSR Clock Range CR[2:0] bits */
    331            tmpreg &= MACMIIAR_CR_MASK;
    332            /* Get hclk frequency value */
    333            RCC_GetClocksFreq(&rcc_clocks);
    334            hclk = rcc_clocks.HCLK_Frequency;
    335            /* Set CR bits depending on hclk value */
    336            if((hclk >= 20000000)&&(hclk < 35000000))
    337            {
    338              /* CSR Clock Range between 20-35 MHz */
    339              tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
    340            }
    341            else if((hclk >= 35000000)&&(hclk < 60000000))
    342            {
    343              /* CSR Clock Range between 35-60 MHz */ 
    344              tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
    345            }  
    346            else if((hclk >= 60000000)&&(hclk < 100000000))
    347            {
    348              /* CSR Clock Range between 60-100 MHz */ 
    349              tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
    350            }  
    351            else /* ((hclk >= 100000000)&&(hclk <= 120000000)) */
    352            {
    353              /* CSR Clock Range between 100-120 MHz */ 
    354              tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
    355            }
    356            
    357            /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
    358            ETH->MACMIIAR = (uint32_t)tmpreg;  
    359            /*-------------------- PHY initialization and configuration ----------------*/
    360            /* Put the PHY in reset mode */
    361            if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
    362            {
    363              /* Return ERROR in case of write timeout */
    364              return ETH_ERROR;
    365            }
    366            
    367            /* Delay to assure PHY reset */
    368            _eth_delay_(PHY_RESET_DELAY);
    369              
    370            if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
    371            {  
    372              /* We wait for linked status... */
    373              do
    374              {
    375                timeout++;
    376              } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
    377          
    378              /* Return ERROR in case of timeout */
    379              if(timeout == PHY_READ_TO)
    380              {
    381                return ETH_ERROR;
    382              }
    383          
    384              /* Reset Timeout counter */
    385              timeout = 0; 
    386              /* Enable Auto-Negotiation */
    387              if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
    388              {
    389                /* Return ERROR in case of write timeout */
    390                return ETH_ERROR;
    391              }
    392          
    393              /* Wait until the auto-negotiation will be completed */
    394              do
    395              {
    396                timeout++;
    397              } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
    398          
    399              /* Return ERROR in case of timeout */
    400              if(timeout == PHY_READ_TO)
    401              {
    402                return ETH_ERROR;
    403              }
    404          
    405              /* Reset Timeout counter */
    406              timeout = 0;
    407              
    408              /* Read the result of the auto-negotiation */
    409              RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
    410            
    411              /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
    412              if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
    413              {
    414                /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
    415                ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
    416              }
    417              else
    418              {
    419                /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
    420                ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
    421              }
    422          
    423              /* Configure the MAC with the speed fixed by the auto-negotiation process */
    424              if(RegValue & PHY_SPEED_STATUS)
    425              {  
    426                /* Set Ethernet speed to 10M following the auto-negotiation */    
    427                ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
    428              }
    429              else
    430              {   
    431                /* Set Ethernet speed to 100M following the auto-negotiation */ 
    432                ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
    433              }    
    434            }
    435            else
    436            {
    437              if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
    438                                                             (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
    439              {
    440                /* Return ERROR in case of write timeout */
    441                return ETH_ERROR;
    442              }
    443              /* Delay to assure PHY configuration */
    444              _eth_delay_(PHY_CONFIG_DELAY);
    445              
    446            }
    447            /*------------------------ ETHERNET MACCR Configuration --------------------*/
    448            /* Get the ETHERNET MACCR value */  
    449            tmpreg = ETH->MACCR;
    450            /* Clear WD, PCE, PS, TE and RE bits */
    451            tmpreg &= MACCR_CLEAR_MASK;
    452            /* Set the WD bit according to ETH_Watchdog value */
    453            /* Set the JD: bit according to ETH_Jabber value */
    454            /* Set the IFG bit according to ETH_InterFrameGap value */ 
    455            /* Set the DCRS bit according to ETH_CarrierSense value */  
    456            /* Set the FES bit according to ETH_Speed value */ 
    457            /* Set the DO bit according to ETH_ReceiveOwn value */ 
    458            /* Set the LM bit according to ETH_LoopbackMode value */ 
    459            /* Set the DM bit according to ETH_Mode value */ 
    460            /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
    461            /* Set the DR bit according to ETH_RetryTransmission value */ 
    462            /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
    463            /* Set the BL bit according to ETH_BackOffLimit value */ 
    464            /* Set the DC bit according to ETH_DeferralCheck value */                          
    465            tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
    466                            ETH_InitStruct->ETH_Jabber | 
    467                            ETH_InitStruct->ETH_InterFrameGap |
    468                            ETH_InitStruct->ETH_CarrierSense |
    469                            ETH_InitStruct->ETH_Speed | 
    470                            ETH_InitStruct->ETH_ReceiveOwn |
    471                            ETH_InitStruct->ETH_LoopbackMode |
    472                            ETH_InitStruct->ETH_Mode | 
    473                            ETH_InitStruct->ETH_ChecksumOffload |    
    474                            ETH_InitStruct->ETH_RetryTransmission | 
    475                            ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
    476                            ETH_InitStruct->ETH_BackOffLimit | 
    477                            ETH_InitStruct->ETH_DeferralCheck);
    478            /* Write to ETHERNET MACCR */
    479            ETH->MACCR = (uint32_t)tmpreg;
    480            
    481            /*----------------------- ETHERNET MACFFR Configuration --------------------*/ 
    482            /* Set the RA bit according to ETH_ReceiveAll value */
    483            /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */
    484            /* Set the PCF bit according to ETH_PassControlFrames value */
    485            /* Set the DBF bit according to ETH_BroadcastFramesReception value */
    486            /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
    487            /* Set the PR bit according to ETH_PromiscuousMode value */
    488            /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
    489            /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
    490            /* Write to ETHERNET MACFFR */  
    491            ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
    492                                    ETH_InitStruct->ETH_SourceAddrFilter |
    493                                    ETH_InitStruct->ETH_PassControlFrames |
    494                                    ETH_InitStruct->ETH_BroadcastFramesReception | 
    495                                    ETH_InitStruct->ETH_DestinationAddrFilter |
    496                                    ETH_InitStruct->ETH_PromiscuousMode |
    497                                    ETH_InitStruct->ETH_MulticastFramesFilter |
    498                                    ETH_InitStruct->ETH_UnicastFramesFilter); 
    499            /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
    500            /* Write to ETHERNET MACHTHR */
    501            ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
    502            /* Write to ETHERNET MACHTLR */
    503            ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
    504            /*----------------------- ETHERNET MACFCR Configuration --------------------*/
    505            /* Get the ETHERNET MACFCR value */  
    506            tmpreg = ETH->MACFCR;
    507            /* Clear xx bits */
    508            tmpreg &= MACFCR_CLEAR_MASK;
    509            
    510            /* Set the PT bit according to ETH_PauseTime value */
    511            /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
    512            /* Set the PLT bit according to ETH_PauseLowThreshold value */
    513            /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
    514            /* Set the RFE bit according to ETH_ReceiveFlowControl value */
    515            /* Set the TFE bit according to ETH_TransmitFlowControl value */  
    516            tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
    517                             ETH_InitStruct->ETH_ZeroQuantaPause |
    518                             ETH_InitStruct->ETH_PauseLowThreshold |
    519                             ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
    520                             ETH_InitStruct->ETH_ReceiveFlowControl |
    521                             ETH_InitStruct->ETH_TransmitFlowControl); 
    522            /* Write to ETHERNET MACFCR */
    523            ETH->MACFCR = (uint32_t)tmpreg;
    524            /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
    525            /* Set the ETV bit according to ETH_VLANTagComparison value */
    526            /* Set the VL bit according to ETH_VLANTagIdentifier value */  
    527            ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
    528                                       ETH_InitStruct->ETH_VLANTagIdentifier); 
    529                 
    530            /*-------------------------------- DMA Config ------------------------------*/
    531            /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
    532            /* Get the ETHERNET DMAOMR value */  
    533            tmpreg = ETH->DMAOMR;
    534            /* Clear xx bits */
    535            tmpreg &= DMAOMR_CLEAR_MASK;
    536            
    537            /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */
    538            /* Set the RSF bit according to ETH_ReceiveStoreForward value */
    539            /* Set the DFF bit according to ETH_FlushReceivedFrame value */
    540            /* Set the TSF bit according to ETH_TransmitStoreForward value */
    541            /* Set the TTC bit according to ETH_TransmitThresholdControl value */
    542            /* Set the FEF bit according to ETH_ForwardErrorFrames value */
    543            /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
    544            /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
    545            /* Set the OSF bit according to ETH_SecondFrameOperate value */
    546            tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
    547                            ETH_InitStruct->ETH_ReceiveStoreForward |
    548                            ETH_InitStruct->ETH_FlushReceivedFrame |
    549                            ETH_InitStruct->ETH_TransmitStoreForward | 
    550                            ETH_InitStruct->ETH_TransmitThresholdControl |
    551                            ETH_InitStruct->ETH_ForwardErrorFrames |
    552                            ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
    553                            ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
    554                            ETH_InitStruct->ETH_SecondFrameOperate); 
    555            /* Write to ETHERNET DMAOMR */
    556            ETH->DMAOMR = (uint32_t)tmpreg;
    557            
    558            /*----------------------- ETHERNET DMABMR Configuration --------------------*/ 
    559            /* Set the AAL bit according to ETH_AddressAlignedBeats value */
    560            /* Set the FB bit according to ETH_FixedBurst value */
    561            /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
    562            /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
    563            /* Set the DSL bit according to ETH_DesciptorSkipLength value */
    564            /* Set the PR and DA bits according to ETH_DMAArbitration value */         
    565            ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
    566                                    ETH_InitStruct->ETH_FixedBurst |
    567                                    ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
    568                                    ETH_InitStruct->ETH_TxDMABurstLength | 
    569                                   (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
    570                                    ETH_InitStruct->ETH_DMAArbitration |
    571                                    ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
    572                                    
    573            #ifdef USE_ENHANCED_DMA_DESCRIPTORS
    574              /* Enable the Enhanced DMA descriptors */
    575              ETH->DMABMR |= ETH_DMABMR_EDE;
    576            #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
    577                                        
    578            /* Return Ethernet configuration success */
    579            return ETH_SUCCESS;
    580          }
    581          
    582          /**
    583            * @brief  Enables ENET MAC and DMA reception/transmission 
    584            * @param  None
    585            * @retval None
    586            */
    587          void ETH_Start(void)
    588          {
    589            /* Enable transmit state machine of the MAC for transmission on the MII */  
    590            ETH_MACTransmissionCmd(ENABLE);
    591            /* Flush Transmit FIFO */
    592            ETH_FlushTransmitFIFO();
    593            /* Enable receive state machine of the MAC for reception from the MII */  
    594            ETH_MACReceptionCmd(ENABLE);
    595           
    596            /* Start DMA transmission */
    597            ETH_DMATransmissionCmd(ENABLE); 
    598            /* Start DMA reception */
    599            ETH_DMAReceptionCmd(ENABLE);   
    600          }
    601          
    602          
    603          /**
    604            * @brief  Enables or disables the MAC transmission.
    605            * @param  NewState: new state of the MAC transmission.
    606            *   This parameter can be: ENABLE or DISABLE.
    607            * @retval None
    608            */
    609          void ETH_MACTransmissionCmd(FunctionalState NewState)
    610          { 
    611            /* Check the parameters */
    612            assert_param(IS_FUNCTIONAL_STATE(NewState));
    613            
    614            if (NewState != DISABLE)
    615            {
    616              /* Enable the MAC transmission */
    617              ETH->MACCR |= ETH_MACCR_TE;  
    618            }
    619            else
    620            {
    621              /* Disable the MAC transmission */
    622              ETH->MACCR &= ~ETH_MACCR_TE;
    623            }
    624          }
    625          
    626          
    627          /**
    628            * @brief  Enables or disables the MAC reception.
    629            * @param  NewState: new state of the MAC reception.
    630            *   This parameter can be: ENABLE or DISABLE.
    631            * @retval None
    632            */
    633          void ETH_MACReceptionCmd(FunctionalState NewState)
    634          { 
    635            /* Check the parameters */
    636            assert_param(IS_FUNCTIONAL_STATE(NewState));
    637            
    638            if (NewState != DISABLE)
    639            {
    640              /* Enable the MAC reception */
    641              ETH->MACCR |= ETH_MACCR_RE;  
    642            }
    643            else
    644            {
    645              /* Disable the MAC reception */
    646              ETH->MACCR &= ~ETH_MACCR_RE;
    647            }
    648          }
    649          
    650          
    651          /**
    652            * @brief  Checks whether the ETHERNET flow control busy bit is set or not.
    653            * @param  None
    654            * @retval The new state of flow control busy status bit (SET or RESET).
    655            */
    656          FlagStatus ETH_GetFlowControlBusyStatus(void)
    657          {
    658            FlagStatus bitstatus = RESET;
    659            /* The Flow Control register should not be written to until this bit is cleared */
    660            if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
    661            {
    662              bitstatus = SET;
    663            }
    664            else
    665            {
    666              bitstatus = RESET;
    667            }
    668            return bitstatus;
    669          }
    670          
    671          
    672          /**
    673            * @brief  Initiate a Pause Control Frame (Full-duplex only).
    674            * @param  None
    675            * @retval None
    676            */
    677          void ETH_InitiatePauseControlFrame(void)  
    678          { 
    679            /* When Set In full duplex MAC initiates pause control frame */
    680            ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
    681          }
    682          
    683          
    684          /**
    685            * @brief  Enables or disables the MAC BackPressure operation activation (Half-duplex only).
    686            * @param  NewState: new state of the MAC BackPressure operation activation.
    687            *   This parameter can be: ENABLE or DISABLE.
    688            * @retval None
    689            */
    690          void ETH_BackPressureActivationCmd(FunctionalState NewState)   
    691          { 
    692            /* Check the parameters */
    693            assert_param(IS_FUNCTIONAL_STATE(NewState));
    694              
    695            if (NewState != DISABLE)
    696            {
    697              /* Activate the MAC BackPressure operation */
    698              /* In Half duplex: during backpressure, when the MAC receives a new frame,
    699              the transmitter starts sending a JAM pattern resulting in a collision */
    700              ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
    701            }
    702            else
    703            {
    704              /* Desactivate the MAC BackPressure operation */
    705              ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
    706            } 
    707          }
    708          
    709          
    710          /**
    711            * @brief  Checks whether the specified ETHERNET MAC flag is set or not.
    712            * @param  ETH_MAC_FLAG: specifies the flag to check.
    713            *   This parameter can be one of the following values:
    714            *     @arg ETH_MAC_FLAG_TST  : Time stamp trigger flag   
    715            *     @arg ETH_MAC_FLAG_MMCT : MMC transmit flag  
    716            *     @arg ETH_MAC_FLAG_MMCR : MMC receive flag   
    717            *     @arg ETH_MAC_FLAG_MMC  : MMC flag  
    718            *     @arg ETH_MAC_FLAG_PMT  : PMT flag  
    719            * @retval The new state of ETHERNET MAC flag (SET or RESET).
    720            */
    721          FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
    722          {
    723            FlagStatus bitstatus = RESET;
    724            /* Check the parameters */
    725            assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
    726            if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
    727            {
    728              bitstatus = SET;
    729            }
    730            else
    731            {
    732              bitstatus = RESET;
    733            }
    734            return bitstatus;
    735          }
    736          
    737          
    738          /**
    739            * @brief  Checks whether the specified ETHERNET MAC interrupt has occurred or not.
    740            * @param  ETH_MAC_IT: specifies the interrupt source to check.
    741            *   This parameter can be one of the following values:
    742            *     @arg ETH_MAC_IT_TST   : Time stamp trigger interrupt  
    743            *     @arg ETH_MAC_IT_MMCT : MMC transmit interrupt 
    744            *     @arg ETH_MAC_IT_MMCR : MMC receive interrupt  
    745            *     @arg ETH_MAC_IT_MMC  : MMC interrupt 
    746            *     @arg ETH_MAC_IT_PMT  : PMT interrupt 
    747            * @retval The new state of ETHERNET MAC interrupt (SET or RESET).
    748            */
    749          ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
    750          {
    751            ITStatus bitstatus = RESET;
    752            /* Check the parameters */
    753            assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
    754            if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
    755            {
    756              bitstatus = SET;
    757            }
    758            else
    759            {
    760              bitstatus = RESET;
    761            }
    762            return bitstatus;
    763          }
    764          
    765          
    766          /**
    767            * @brief  Enables or disables the specified ETHERNET MAC interrupts.
    768            * @param  ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be
    769            *   enabled or disabled.
    770            *   This parameter can be any combination of the following values:
    771            *     @arg ETH_MAC_IT_TST : Time stamp trigger interrupt 
    772            *     @arg ETH_MAC_IT_PMT : PMT interrupt 
    773            * @param  NewState: new state of the specified ETHERNET MAC interrupts.
    774            *   This parameter can be: ENABLE or DISABLE.
    775            * @retval None
    776            */
    777          void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
    778          {
    779            /* Check the parameters */
    780            assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
    781            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    782            
    783            if (NewState != DISABLE)
    784            {
    785              /* Enable the selected ETHERNET MAC interrupts */
    786              ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
    787            }
    788            else
    789            {
    790              /* Disable the selected ETHERNET MAC interrupts */
    791              ETH->MACIMR |= ETH_MAC_IT;
    792            }
    793          }
    794          
    795          
    796          /**
    797            * @brief  Configures the selected MAC address.
    798            * @param  MacAddr: The MAC address to configure.
    799            *   This parameter can be one of the following values:
    800            *     @arg ETH_MAC_Address0 : MAC Address0 
    801            *     @arg ETH_MAC_Address1 : MAC Address1 
    802            *     @arg ETH_MAC_Address2 : MAC Address2
    803            *     @arg ETH_MAC_Address3 : MAC Address3
    804            * @param  Addr: Pointer on MAC address buffer data (6 bytes).
    805            * @retval None
    806            */
    807          void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
    808          {
    809            uint32_t tmpreg;
    810            /* Check the parameters */
    811            assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
    812            
    813            /* Calculate the selected MAC address high register */
    814            tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
    815            /* Load the selected MAC address high register */
    816            (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
    817            /* Calculate the selected MAC address low register */
    818            tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
    819           
    820            /* Load the selected MAC address low register */
    821            (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
    822          }
    823          
    824          
    825          /**
    826            * @brief  Get the selected MAC address.
    827            * @param  MacAddr: The MAC address to return.
    828            *   This parameter can be one of the following values:
    829            *     @arg ETH_MAC_Address0 : MAC Address0 
    830            *     @arg ETH_MAC_Address1 : MAC Address1 
    831            *     @arg ETH_MAC_Address2 : MAC Address2
    832            *     @arg ETH_MAC_Address3 : MAC Address3
    833            * @param  Addr: Pointer on MAC address buffer data (6 bytes).
    834            * @retval None
    835            */
    836          void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
    837          {
    838            uint32_t tmpreg;
    839            /* Check the parameters */
    840            assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
    841            
    842            /* Get the selected MAC address high register */
    843            tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
    844           
    845            /* Calculate the selected MAC address buffer */
    846            Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
    847            Addr[4] = (tmpreg & (uint8_t)0xFF);
    848            /* Load the selected MAC address low register */
    849            tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
    850            /* Calculate the selected MAC address buffer */
    851            Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
    852            Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
    853            Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
    854            Addr[0] = (tmpreg & (uint8_t)0xFF);
    855          }
    856          
    857          
    858          /**
    859            * @brief  Enables or disables the Address filter module uses the specified
    860            *   ETHERNET MAC address for perfect filtering 
    861            * @param  MacAddr: specifies the ETHERNET MAC address to be used for perfect filtering.
    862            *   This parameter can be one of the following values: 
    863            *     @arg ETH_MAC_Address1 : MAC Address1 
    864            *     @arg ETH_MAC_Address2 : MAC Address2
    865            *     @arg ETH_MAC_Address3 : MAC Address3
    866            * @param  NewState: new state of the specified ETHERNET MAC address use.
    867            *   This parameter can be: ENABLE or DISABLE.
    868            * @retval None
    869            */
    870          void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
    871          {
    872            /* Check the parameters */
    873            assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    874            assert_param(IS_FUNCTIONAL_STATE(NewState));
    875              
    876            if (NewState != DISABLE)
    877            {
    878              /* Enable the selected ETHERNET MAC address for perfect filtering */
    879              (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
    880            }
    881            else
    882            {
    883              /* Disable the selected ETHERNET MAC address for perfect filtering */
    884              (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
    885            }
    886          }
    887          
    888          
    889          /**
    890            * @brief  Set the filter type for the specified ETHERNET MAC address 
    891            * @param  MacAddr: specifies the ETHERNET MAC address 
    892            *   This parameter can be one of the following values: 
    893            *     @arg ETH_MAC_Address1 : MAC Address1 
    894            *     @arg ETH_MAC_Address2 : MAC Address2
    895            *     @arg ETH_MAC_Address3 : MAC Address3
    896            * @param  Filter: specifies the used frame received field for comparison 
    897            *   This parameter can be one of the following values: 
    898            *     @arg ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the
    899            *                                     SA fields of the received frame.
    900            *     @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the
    901            *                                     DA fields of the received frame.
    902            * @retval None
    903            */
    904          void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
    905          {
    906            /* Check the parameters */
    907            assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    908            assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
    909            
    910            if (Filter != ETH_MAC_AddressFilter_DA)
    911            {
    912              /* The selected ETHERNET MAC address is used to compare with the SA fields of the
    913                 received frame. */
    914              (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
    915            }
    916            else
    917            {
    918              /* The selected ETHERNET MAC address is used to compare with the DA fields of the
    919                 received frame. */
    920              (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
    921            }
    922          }
    923          
    924          
    925          /**
    926            * @brief  Set the filter type for the specified ETHERNET MAC address 
    927            * @param  MacAddr: specifies the ETHERNET MAC address 
    928            *   This parameter can be one of the following values: 
    929            *     @arg ETH_MAC_Address1 : MAC Address1 
    930            *     @arg ETH_MAC_Address2 : MAC Address2
    931            *     @arg ETH_MAC_Address3 : MAC Address3
    932            * @param  MaskByte: specifies the used address bytes for comparison 
    933            *   This parameter can be any combination of the following values: 
    934            *     @arg ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8].
    935            *     @arg ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0].
    936            *     @arg ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24].
    937            *     @arg ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16].
    938            *     @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8].
    939            *     @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0].
    940            * @retval None
    941            */
    942          void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
    943          {
    944            /* Check the parameters */
    945            assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    946            assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
    947            
    948            /* Clear MBC bits in the selected MAC address  high register */
    949            (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
    950            /* Set the selected Filter mask bytes */
    951            (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
    952          }
    953          
    954          
    955          /******************************************************************************/                             
    956          /*                           DMA Descriptors functions                        */
    957          /******************************************************************************/
    958          
    959          /**
    960            * @brief  This function should be called to get the received frame (to be used 
    961            * with polling method only).
    962            * @param  none
    963            * @retval Structure of type FrameTypeDef
    964            */
    965          FrameTypeDef ETH_Get_Received_Frame(void)
    966          { 
    967            uint32_t framelength = 0;
    968            FrameTypeDef frame = {0,0,0}; 
    969            
    970            /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    971            framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
    972            frame.length = framelength;
    973            
    974            /* Get the address of the buffer start address */ 
    975            /* Check if more than one segment in the frame */
    976            if (DMA_RX_FRAME_infos->Seg_Count >1)
    977            {
    978              frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
    979            }
    980            else 
    981            {
    982              frame.buffer = DMARxDescToGet->Buffer1Addr;
    983            }
    984          
    985            frame.descriptor = DMARxDescToGet;
    986            
    987            /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
    988            /* Chained Mode */    
    989            /* Selects the next DMA Rx descriptor list for next buffer to read */ 
    990            DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
    991            
    992            /* Return Frame */
    993            return (frame);  
    994          }
    995          
    996          
    997          /**
    998            * @brief  This function should be called when a frame is received using DMA 
    999            *         Receive interrupt, it allows scanning of Rx descriptors to get the
   1000            *         the receive frame (should be used with interrupt mode only)
   1001            * @param  None
   1002            * @retval Structure of type FrameTypeDef
   1003            */
   1004          FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
   1005          { 
   1006            FrameTypeDef frame={0,0,0};
   1007            __IO uint32_t descriptor_scan_counter = 0; 
   1008            
   1009            /* scan descriptors owned by CPU */
   1010            while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
   1011                  (descriptor_scan_counter<ETH_RXBUFNB))
   1012            {
   1013              
   1014              /* Just by security */
   1015              descriptor_scan_counter++;
   1016              
   1017              /* check if first segment in frame */
   1018              if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
   1019                ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
   1020              {
   1021                DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
   1022                DMA_RX_FRAME_infos->Seg_Count = 1;   
   1023                DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
   1024              }
   1025              
   1026              /* check if intermediate segment */
   1027              else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
   1028                      ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
   1029              {
   1030                (DMA_RX_FRAME_infos->Seg_Count) ++;
   1031                DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
   1032              }
   1033          
   1034              /* should be last segment */
   1035              else
   1036              { 
   1037                /* last segment */
   1038                DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
   1039                
   1040                (DMA_RX_FRAME_infos->Seg_Count)++;
   1041                  
   1042                /* first segment is last segment */
   1043                if ((DMA_RX_FRAME_infos->Seg_Count)==1)
   1044                  DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
   1045                
   1046                /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
   1047                frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
   1048          
   1049            
   1050                /* Get the address of the buffer start address */ 
   1051                /* Check if more than one segment in the frame */
   1052                if (DMA_RX_FRAME_infos->Seg_Count >1)
   1053                {
   1054                  frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
   1055                }
   1056                else 
   1057                {
   1058                  frame.buffer = DMARxDescToGet->Buffer1Addr;
   1059                }
   1060                
   1061                frame.descriptor = DMARxDescToGet;
   1062            
   1063                /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
   1064                DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
   1065               
   1066                /* Return Frame */
   1067                return (frame);  
   1068              }
   1069            }
   1070            return (frame); 
   1071          }
   1072                
   1073                    
   1074          /**
   1075            * @brief  Prepares DMA Tx descriptors to transmit an ethernet frame
   1076            * @param  FrameLength : length of the frame to send
   1077            * @retval error status
   1078            */
   1079          uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
   1080          {   
   1081            uint32_t buf_count =0, size=0,i=0;
   1082            __IO ETH_DMADESCTypeDef *DMATxNextDesc;
   1083            
   1084            /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
   1085            if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
   1086            {  
   1087              /* Return ERROR: OWN bit set */
   1088              return ETH_ERROR;
   1089            }
   1090            
   1091            DMATxNextDesc = DMATxDescToSet;
   1092            
   1093            if (FrameLength > ETH_TX_BUF_SIZE)
   1094            {
   1095              buf_count = FrameLength/ETH_TX_BUF_SIZE;
   1096              if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
   1097            }
   1098            else buf_count =1;
   1099            
   1100            if (buf_count ==1)
   1101            {
   1102              /*set LAST and FIRST segment */
   1103              DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
   1104              /* Set frame size */
   1105              DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
   1106              /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
   1107              DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
   1108              DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
   1109            }
   1110            else
   1111            {
   1112              for (i=0; i< buf_count; i++)
   1113              {
   1114                if (i==0) 
   1115                {
   1116                  /* Setting the first segment bit */
   1117                  DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
   1118                }
   1119                
   1120                /* Program size */
   1121                DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
   1122                 
   1123                if (i== (buf_count-1))
   1124                {
   1125                  /* Setting the last segment bit */
   1126                  DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
   1127                  size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
   1128                  DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
   1129                }
   1130                  
   1131                /*give back descriptor to DMA */
   1132                DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
   1133                
   1134                DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
   1135                /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
   1136               }
   1137              DMATxDescToSet = DMATxNextDesc ;
   1138            }
   1139              
   1140            /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
   1141            if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
   1142            {
   1143              /* Clear TBUS ETHERNET DMA flag */
   1144              ETH->DMASR = ETH_DMASR_TBUS;
   1145              /* Resume DMA transmission*/
   1146              ETH->DMATPDR = 0;
   1147            }
   1148            
   1149            /* Return SUCCESS */
   1150            return ETH_SUCCESS;   
   1151          }
   1152          
   1153          
   1154          /**
   1155            * @brief  Initializes the DMA Rx descriptors in chain mode.
   1156            * @param  DMARxDescTab: Pointer on the first Rx desc list 
   1157            * @param  RxBuff: Pointer on the first RxBuffer list
   1158            * @param  RxBuffCount: Number of the used Rx desc in the list
   1159            * @retval None
   1160            */
   1161          void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
   1162          {
   1163            uint32_t i = 0;
   1164            ETH_DMADESCTypeDef *DMARxDesc;
   1165            
   1166            /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
   1167            DMARxDescToGet = DMARxDescTab; 
   1168            /* Fill each DMARxDesc descriptor with the right values */
   1169            for(i=0; i < RxBuffCount; i++)
   1170            {
   1171              /* Get the pointer on the ith member of the Rx Desc list */
   1172              DMARxDesc = DMARxDescTab+i;
   1173              /* Set Own bit of the Rx descriptor Status */
   1174              DMARxDesc->Status = ETH_DMARxDesc_OWN;
   1175          
   1176              /* Set Buffer1 size and Second Address Chained bit */
   1177              DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
   1178              /* Set Buffer1 address pointer */
   1179              DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
   1180              
   1181              /* Initialize the next descriptor with the Next Descriptor Polling Enable */
   1182              if(i < (RxBuffCount-1))
   1183              {
   1184                /* Set next descriptor address register with next descriptor base address */
   1185                DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
   1186              }
   1187              else
   1188              {
   1189                /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
   1190                DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
   1191              }
   1192            }
   1193             
   1194            /* Set Receive Descriptor List Address Register */
   1195            ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
   1196            
   1197          
   1198            DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
   1199          
   1200          }
   1201          
   1202          /**
   1203            * @brief  This function polls for a frame reception
   1204            * @param  None
   1205            * @retval Returns 1 when a frame is received, 0 if none.
   1206            */
   1207          uint32_t ETH_CheckFrameReceived(void)
   1208          { 
   1209            /* check if last segment */
   1210            if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   1211               ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
   1212              {   
   1213                DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
   1214                DMA_RX_FRAME_infos->Seg_Count++;
   1215                return 1;
   1216              }
   1217            
   1218              /* check if first segment */
   1219              else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   1220               ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
   1221               ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
   1222              {
   1223                DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
   1224                DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
   1225                DMA_RX_FRAME_infos->Seg_Count = 1;   
   1226                DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
   1227              }
   1228              
   1229              /* check if intermediate segment */ 
   1230              else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   1231               ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
   1232               ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
   1233              {
   1234                (DMA_RX_FRAME_infos->Seg_Count) ++;
   1235                DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
   1236              } 
   1237              return 0;
   1238          }
   1239          
   1240          
   1241          
   1242          /**
   1243            * @brief  Initializes the DMA Tx descriptors in chain mode.
   1244            * @param  DMATxDescTab: Pointer on the first Tx desc list 
   1245            * @param  TxBuff: Pointer on the first TxBuffer list
   1246            * @param  TxBuffCount: Number of the used Tx desc in the list
   1247            * @retval None
   1248            */
   1249          void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
   1250          {
   1251            uint32_t i = 0;
   1252            ETH_DMADESCTypeDef *DMATxDesc;
   1253            
   1254            /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
   1255            DMATxDescToSet = DMATxDescTab;
   1256            /* Fill each DMATxDesc descriptor with the right values */   
   1257            for(i=0; i < TxBuffCount; i++)
   1258            {
   1259              /* Get the pointer on the ith member of the Tx Desc list */
   1260              DMATxDesc = DMATxDescTab + i;
   1261              /* Set Second Address Chained bit */
   1262              DMATxDesc->Status = ETH_DMATxDesc_TCH;  
   1263                 
   1264              /* Set Buffer1 address pointer */
   1265              DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
   1266              
   1267              /* Initialize the next descriptor with the Next Descriptor Polling Enable */
   1268              if(i < (TxBuffCount-1))
   1269              {
   1270                /* Set next descriptor address register with next descriptor base address */
   1271                DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
   1272              }
   1273              else
   1274              {
   1275                /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
   1276                DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
   1277              }
   1278            }
   1279             
   1280            /* Set Transmit Desciptor List Address Register */
   1281            ETH->DMATDLAR = (uint32_t) DMATxDescTab;
   1282          }
   1283          
   1284          
   1285          
   1286          
   1287          /**
   1288            * @brief  Checks whether the specified ETHERNET DMA Tx Desc flag is set or not.
   1289            * @param  DMATxDesc: pointer on a DMA Tx descriptor
   1290            * @param  ETH_DMATxDescFlag: specifies the flag to check.
   1291            *   This parameter can be one of the following values:
   1292            *     @arg ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine
   1293            *     @arg ETH_DMATxDesc_IC  : Interrupt on completion
   1294            *     @arg ETH_DMATxDesc_LS  : Last Segment
   1295            *     @arg ETH_DMATxDesc_FS  : First Segment
   1296            *     @arg ETH_DMATxDesc_DC  : Disable CRC
   1297            *     @arg ETH_DMATxDesc_DP  : Disable Pad
   1298            *     @arg ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable
   1299            *     @arg ETH_DMATxDesc_CIC : Checksum insertion control      
   1300            *     @arg ETH_DMATxDesc_TER : Transmit End of Ring
   1301            *     @arg ETH_DMATxDesc_TCH : Second Address Chained
   1302            *     @arg ETH_DMATxDesc_TTSS: Tx Time Stamp Status
   1303            *     @arg ETH_DMATxDesc_IHE : IP Header Error
   1304            *     @arg ETH_DMATxDesc_ES  : Error summary
   1305            *     @arg ETH_DMATxDesc_JT  : Jabber Timeout
   1306            *     @arg ETH_DMATxDesc_FF  : Frame Flushed: DMA/MTL flushed the frame due to SW flush
   1307            *     @arg ETH_DMATxDesc_PCE : Payload Checksum Error
   1308            *     @arg ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during transmission
   1309            *     @arg ETH_DMATxDesc_NC  : No Carrier: no carrier signal from the transceiver
   1310            *     @arg ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision
   1311            *     @arg ETH_DMATxDesc_EC  : Excessive Collision: transmission aborted after 16 collisions
   1312            *     @arg ETH_DMATxDesc_VF  : VLAN Frame
   1313            *     @arg ETH_DMATxDesc_CC  : Collision Count 
   1314            *     @arg ETH_DMATxDesc_ED  : Excessive Deferral
   1315            *     @arg ETH_DMATxDesc_UF  : Underflow Error: late data arrival from the memory
   1316            *     @arg ETH_DMATxDesc_DB  : Deferred Bit
   1317            * @retval The new state of ETH_DMATxDescFlag (SET or RESET).
   1318            */
   1319          FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
   1320          {
   1321            FlagStatus bitstatus = RESET;
   1322            /* Check the parameters */
   1323            assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
   1324            
   1325            if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
   1326            {
   1327              bitstatus = SET;
   1328            }
   1329            else
   1330            {
   1331              bitstatus = RESET;
   1332            }
   1333            return bitstatus;
   1334          }
   1335          
   1336          /**
   1337            * @brief  Returns the specified ETHERNET DMA Tx Desc collision count.
   1338            * @param  DMATxDesc: pointer on a DMA Tx descriptor                     
   1339            * @retval The Transmit descriptor collision counter value.
   1340            */
   1341          uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
   1342          {
   1343            /* Return the Receive descriptor frame length */
   1344            return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
   1345          }
   1346          
   1347          /**
   1348            * @brief  Set the specified DMA Tx Desc Own bit.
   1349            * @param  DMATxDesc: Pointer on a Tx desc
   1350            * @retval None
   1351            */
   1352          void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
   1353          {
   1354            /* Set the DMA Tx Desc Own bit */
   1355            DMATxDesc->Status |= ETH_DMATxDesc_OWN;
   1356          }
   1357          
   1358          /**
   1359            * @brief  Enables or disables the specified DMA Tx Desc Transmit interrupt.
   1360            * @param  DMATxDesc: Pointer on a Tx desc
   1361            * @param  NewState: new state of the DMA Tx Desc transmit interrupt.
   1362            *   This parameter can be: ENABLE or DISABLE.                   
   1363            * @retval None
   1364            */
   1365          void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
   1366          {
   1367            /* Check the parameters */
   1368            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1369            
   1370            if (NewState != DISABLE)
   1371            {
   1372              /* Enable the DMA Tx Desc Transmit interrupt */
   1373              DMATxDesc->Status |= ETH_DMATxDesc_IC;
   1374            }
   1375            else
   1376            {
   1377              /* Disable the DMA Tx Desc Transmit interrupt */
   1378              DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
   1379            }
   1380          }
   1381          
   1382          /**
   1383            * @brief  configure Tx descriptor as last or first segment
   1384            * @param  DMATxDesc: Pointer on a Tx desc
   1385            * @param  DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment.
   1386            *   This parameter can be one of the following values:
   1387            *     @arg ETH_DMATxDesc_LastSegment  : actual Tx desc contain last segment 
   1388            *     @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment                   
   1389            * @retval None
   1390            */
   1391          void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
   1392          {
   1393            /* Check the parameters */
   1394            assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
   1395            
   1396            /* Selects the DMA Tx Desc Frame segment */
   1397            DMATxDesc->Status |= DMATxDesc_FrameSegment;
   1398          }
   1399          
   1400          /**
   1401            * @brief  Selects the specified ETHERNET DMA Tx Desc Checksum Insertion.
   1402            * @param  DMATxDesc: pointer on a DMA Tx descriptor 
   1403            * @param  DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion.
   1404            *   This parameter can be one of the following values:
   1405            *     @arg ETH_DMATxDesc_ChecksumByPass : Checksum bypass
   1406            *     @arg ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum
   1407            *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
   1408            *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
   1409            * @retval None
   1410            */
   1411          void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
   1412          {
   1413            /* Check the parameters */
   1414            assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
   1415            
   1416            /* Set the selected DMA Tx desc checksum insertion control */
   1417            DMATxDesc->Status |= DMATxDesc_Checksum;
   1418          }
   1419          
   1420          /**
   1421            * @brief  Enables or disables the DMA Tx Desc CRC.
   1422            * @param  DMATxDesc: pointer on a DMA Tx descriptor
   1423            * @param  NewState: new state of the specified DMA Tx Desc CRC.
   1424            *   This parameter can be: ENABLE or DISABLE.
   1425            * @retval None
   1426            */
   1427          void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
   1428          {
   1429            /* Check the parameters */
   1430            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1431            
   1432            if (NewState != DISABLE)
   1433            {
   1434              /* Enable the selected DMA Tx Desc CRC */
   1435              DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
   1436            }
   1437            else
   1438            {
   1439              /* Disable the selected DMA Tx Desc CRC */
   1440              DMATxDesc->Status |= ETH_DMATxDesc_DC; 
   1441            }
   1442          }
   1443          
   1444          
   1445          /**
   1446            * @brief  Enables or disables the DMA Tx Desc second address chained.
   1447            * @param  DMATxDesc: pointer on a DMA Tx descriptor
   1448            * @param  NewState: new state of the specified DMA Tx Desc second address chained.
   1449            *   This parameter can be: ENABLE or DISABLE.
   1450            * @retval None
   1451            */
   1452          void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
   1453          {
   1454            /* Check the parameters */
   1455            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1456            
   1457            if (NewState != DISABLE)
   1458            {
   1459              /* Enable the selected DMA Tx Desc second address chained */
   1460              DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
   1461            }
   1462            else
   1463            {
   1464              /* Disable the selected DMA Tx Desc second address chained */
   1465              DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
   1466            }
   1467          }
   1468          
   1469          /**
   1470            * @brief  Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes.
   1471            * @param  DMATxDesc: pointer on a DMA Tx descriptor
   1472            * @param  NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes.
   1473            *   This parameter can be: ENABLE or DISABLE.
   1474            * @retval None
   1475            */
   1476          void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
   1477          {
   1478            /* Check the parameters */
   1479            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1480            
   1481            if (NewState != DISABLE)
   1482            {
   1483              /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
   1484              DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
   1485            }
   1486            else
   1487            {
   1488              /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
   1489              DMATxDesc->Status |= ETH_DMATxDesc_DP; 
   1490            }
   1491          }
   1492          
   1493          
   1494          /**
   1495            * @brief  Configures the specified DMA Tx Desc buffer1 and buffer2 sizes.
   1496            * @param  DMATxDesc: Pointer on a Tx desc
   1497            * @param  BufferSize1: specifies the Tx desc buffer1 size.
   1498            * @param  BufferSize2: specifies the Tx desc buffer2 size (put "0" if not used).
   1499            * @retval None
   1500            */
   1501          void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
   1502          {
   1503            /* Check the parameters */
   1504            assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
   1505            assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
   1506            
   1507            /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
   1508            DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
   1509          }
   1510          
   1511          
   1512          /**
   1513            * @brief  Checks whether the specified ETHERNET Rx Desc flag is set or not.
   1514            * @param  DMARxDesc: pointer on a DMA Rx descriptor
   1515            * @param  ETH_DMARxDescFlag: specifies the flag to check.
   1516            *   This parameter can be one of the following values:
   1517            *     @arg ETH_DMARxDesc_OWN:         OWN bit: descriptor is owned by DMA engine 
   1518            *     @arg ETH_DMARxDesc_AFM:         DA Filter Fail for the rx frame
   1519            *     @arg ETH_DMARxDesc_ES:          Error summary
   1520            *     @arg ETH_DMARxDesc_DE:          Descriptor error: no more descriptors for receive frame
   1521            *     @arg ETH_DMARxDesc_SAF:         SA Filter Fail for the received frame
   1522            *     @arg ETH_DMARxDesc_LE:          Frame size not matching with length field
   1523            *     @arg ETH_DMARxDesc_OE:          Overflow Error: Frame was damaged due to buffer overflow
   1524            *     @arg ETH_DMARxDesc_VLAN:        VLAN Tag: received frame is a VLAN frame
   1525            *     @arg ETH_DMARxDesc_FS:          First descriptor of the frame
   1526            *     @arg ETH_DMARxDesc_LS:          Last descriptor of the frame
   1527            *     @arg ETH_DMARxDesc_IPV4HCE:     IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error 
   1528            *     @arg ETH_DMARxDesc_LC:          Late collision occurred during reception
   1529            *     @arg ETH_DMARxDesc_FT:          Frame type - Ethernet, otherwise 802.3
   1530            *     @arg ETH_DMARxDesc_RWT:         Receive Watchdog Timeout: watchdog timer expired during reception
   1531            *     @arg ETH_DMARxDesc_RE:          Receive error: error reported by MII interface
   1532            *     @arg ETH_DMARxDesc_DE:          Dribble bit error: frame contains non int multiple of 8 bits
   1533            *     @arg ETH_DMARxDesc_CE:          CRC error
   1534            *     @arg ETH_DMARxDesc_MAMPCE:      Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error
   1535            * @retval The new state of ETH_DMARxDescFlag (SET or RESET).
   1536            */
   1537          FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
   1538          {
   1539            FlagStatus bitstatus = RESET;
   1540            /* Check the parameters */
   1541            assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
   1542            if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
   1543            {
   1544              bitstatus = SET;
   1545            }
   1546            else
   1547            {
   1548              bitstatus = RESET;
   1549            }
   1550            return bitstatus;
   1551          }
   1552          
   1553          #ifdef USE_ENHANCED_DMA_DESCRIPTORS
   1554          /**
   1555            * @brief  Checks whether the specified ETHERNET PTP Rx Desc extended flag is set or not.
   1556            * @param  DMAPTPRxDesc: pointer on a DMA PTP Rx descriptor
   1557            * @param  ETH_DMAPTPRxDescFlag: specifies the extended flag to check.
   1558            *   This parameter can be one of the following values:
   1559            *     @arg ETH_DMAPTPRxDesc_PTPV:   PTP version  
   1560            *     @arg ETH_DMAPTPRxDesc_PTPFT:  PTP frame type
   1561            *     @arg ETH_DMAPTPRxDesc_PTPMT:  PTP message type   
   1562            *     @arg ETH_DMAPTPRxDesc_IPV6PR: IPv6 packet received   
   1563            *     @arg ETH_DMAPTPRxDesc_IPV4PR: IPv4 packet received    
   1564            *     @arg ETH_DMAPTPRxDesc_IPCB:   IP checksum bypassed  
   1565            *     @arg ETH_DMAPTPRxDesc_IPPE:   IP payload error
   1566            *     @arg ETH_DMAPTPRxDesc_IPHE:   IP header error 
   1567            *     @arg ETH_DMAPTPRxDesc_IPPT:   IP payload type 
   1568            * @retval The new state of ETH_DMAPTPRxDescExtendedFlag (SET or RESET).
   1569            */
   1570          FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag)
   1571          {
   1572            FlagStatus bitstatus = RESET;
   1573          
   1574            /* Check the parameters */
   1575            assert_param(IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(ETH_DMAPTPRxDescExtendedFlag));
   1576          
   1577            if ((DMAPTPRxDesc->ExtendedStatus & ETH_DMAPTPRxDescExtendedFlag) != (uint32_t)RESET)
   1578            {
   1579              bitstatus = SET;
   1580            }
   1581            else
   1582            {
   1583              bitstatus = RESET;
   1584            }
   1585            return bitstatus;
   1586          }
   1587          #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
   1588          
   1589          /**
   1590            * @brief  Set the specified DMA Rx Desc Own bit.
   1591            * @param  DMARxDesc: Pointer on a Rx desc
   1592            * @retval None
   1593            */
   1594          void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
   1595          {
   1596            /* Set the DMA Rx Desc Own bit */
   1597            DMARxDesc->Status |= ETH_DMARxDesc_OWN;
   1598          }
   1599          
   1600          /**
   1601            * @brief  Returns the specified DMA Rx Desc frame length.
   1602            * @param  DMARxDesc: pointer on a DMA Rx descriptor                     
   1603            * @retval The Rx descriptor received frame length.
   1604            */
   1605          uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
   1606          {
   1607            /* Return the Receive descriptor frame length */
   1608            return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
   1609          }
   1610          
   1611          /**
   1612            * @brief  Enables or disables the specified DMA Rx Desc receive interrupt.
   1613            * @param  DMARxDesc: Pointer on a Rx desc
   1614            * @param  NewState: new state of the specified DMA Rx Desc interrupt.
   1615            *   This parameter can be: ENABLE or DISABLE.                   
   1616            * @retval None
   1617            */
   1618          void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
   1619          {
   1620            /* Check the parameters */
   1621            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1622            
   1623            if (NewState != DISABLE)
   1624            {
   1625              /* Enable the DMA Rx Desc receive interrupt */
   1626              DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
   1627            }
   1628            else
   1629            {
   1630              /* Disable the DMA Rx Desc receive interrupt */
   1631              DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
   1632            }
   1633          }
   1634          
   1635          
   1636          /**
   1637            * @brief  Returns the specified ETHERNET DMA Rx Desc buffer size.
   1638            * @param  DMARxDesc: pointer on a DMA Rx descriptor 
   1639            * @param  DMARxDesc_Buffer: specifies the DMA Rx Desc buffer.
   1640            *   This parameter can be any one of the following values:
   1641            *     @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1
   1642            *     @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2                     
   1643            * @retval The Receive descriptor frame length.
   1644            */
   1645          uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
   1646          {
   1647            /* Check the parameters */
   1648            assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
   1649            
   1650            if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
   1651            {
   1652              /* Return the DMA Rx Desc buffer2 size */
   1653              return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
   1654            }
   1655            else
   1656            {
   1657              /* Return the DMA Rx Desc buffer1 size */
   1658              return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
   1659            }
   1660          }
   1661          
   1662          
   1663          /**
   1664            * @brief  Get the size of the received packet.
   1665            * @param  None
   1666            * @retval framelength: received packet size 
   1667            */
   1668          uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
   1669          {
   1670            uint32_t frameLength = 0;
   1671            if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   1672               ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
   1673               ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
   1674            {
   1675              /* Get the size of the packet: including 4 bytes of the CRC */
   1676              frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
   1677            }
   1678            
   1679            /* Return Frame Length */ 
   1680            return frameLength;
   1681          }
   1682          
   1683          #ifdef USE_ENHANCED_DMA_DESCRIPTORS
   1684          /**
   1685            * @brief  Enables or disables the Enhanced descriptor structure.
   1686            * @param  NewState: new state of the Enhanced descriptor structure.
   1687            *   This parameter can be: ENABLE or DISABLE. 
   1688            * @retval None
   1689            */
   1690          void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
   1691          { 
   1692            /* Check the parameters */
   1693            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1694            
   1695            if (NewState != DISABLE)
   1696            {
   1697              /* Enable enhanced descriptor structure */
   1698              ETH->DMABMR |= ETH_DMABMR_EDE;  
   1699            }
   1700            else
   1701            {
   1702              /* Disable enhanced descriptor structure */
   1703              ETH->DMABMR &= ~ETH_DMABMR_EDE;
   1704            }
   1705          }
   1706          #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
   1707          
   1708          /******************************************************************************/                             
   1709          /*                           DMA functions                                    */
   1710          /******************************************************************************/
   1711          /**
   1712            * @brief  Resets all MAC subsystem internal registers and logic.
   1713            * @param  None
   1714            * @retval None
   1715            */
   1716          void ETH_SoftwareReset(void)
   1717          {
   1718            /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
   1719            /* After reset all the registers holds their respective reset values */
   1720            ETH->DMABMR |= ETH_DMABMR_SR;
   1721          }
   1722          
   1723          /**
   1724            * @brief  Checks whether the ETHERNET software reset bit is set or not.
   1725            * @param  None
   1726            * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
   1727            */
   1728          FlagStatus ETH_GetSoftwareResetStatus(void)
   1729          {
   1730            FlagStatus bitstatus = RESET;
   1731            if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
   1732            {
   1733              bitstatus = SET;
   1734            }
   1735            else
   1736            {
   1737              bitstatus = RESET;
   1738            }
   1739            return bitstatus;
   1740          }
   1741          
   1742          /**
   1743            * @brief  Checks whether the specified ETHERNET DMA flag is set or not.
   1744            * @param  ETH_DMA_FLAG: specifies the flag to check.
   1745            *   This parameter can be one of the following values:
   1746            *     @arg ETH_DMA_FLAG_TST : Time-stamp trigger flag
   1747            *     @arg ETH_DMA_FLAG_PMT : PMT flag 
   1748            *     @arg ETH_DMA_FLAG_MMC : MMC flag 
   1749            *     @arg ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access
   1750            *     @arg ETH_DMA_FLAG_ReadWriteError    : Error bits 0-write trnsf, 1-read transfr
   1751            *     @arg ETH_DMA_FLAG_AccessError       : Error bits 0-Rx DMA, 1-Tx DMA
   1752            *     @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag
   1753            *     @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag  
   1754            *     @arg ETH_DMA_FLAG_ER  : Early receive flag 
   1755            *     @arg ETH_DMA_FLAG_FBE : Fatal bus error flag 
   1756            *     @arg ETH_DMA_FLAG_ET  : Early transmit flag 
   1757            *     @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag 
   1758            *     @arg ETH_DMA_FLAG_RPS : Receive process stopped flag 
   1759            *     @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag 
   1760            *     @arg ETH_DMA_FLAG_R   : Receive flag 
   1761            *     @arg ETH_DMA_FLAG_TU  : Underflow flag 
   1762            *     @arg ETH_DMA_FLAG_RO  : Overflow flag 
   1763            *     @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag 
   1764            *     @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag 
   1765            *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
   1766            *     @arg ETH_DMA_FLAG_T   : Transmit flag 
   1767            * @retval The new state of ETH_DMA_FLAG (SET or RESET).
   1768            */
   1769          FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
   1770          {  
   1771            FlagStatus bitstatus = RESET;
   1772            /* Check the parameters */
   1773            assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
   1774            if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
   1775            {
   1776              bitstatus = SET;
   1777            }
   1778            else
   1779            {
   1780              bitstatus = RESET;
   1781            }
   1782            return bitstatus;
   1783          }
   1784          
   1785          /**
   1786            * @brief  Clears the ETHERNETs DMA pending flag.
   1787            * @param  ETH_DMA_FLAG: specifies the flag to clear.
   1788            *   This parameter can be any combination of the following values:
   1789            *     @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag
   1790            *     @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag 
   1791            *     @arg ETH_DMA_FLAG_ER  : Early receive flag 
   1792            *     @arg ETH_DMA_FLAG_FBE : Fatal bus error flag 
   1793            *     @arg ETH_DMA_FLAG_ETI : Early transmit flag 
   1794            *     @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag 
   1795            *     @arg ETH_DMA_FLAG_RPS : Receive process stopped flag 
   1796            *     @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag 
   1797            *     @arg ETH_DMA_FLAG_R   : Receive flag 
   1798            *     @arg ETH_DMA_FLAG_TU  : Transmit Underflow flag 
   1799            *     @arg ETH_DMA_FLAG_RO  : Receive Overflow flag 
   1800            *     @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag 
   1801            *     @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag 
   1802            *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
   1803            *     @arg ETH_DMA_FLAG_T   : Transmit flag
   1804            * @retval None
   1805            */
   1806          void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
   1807          {
   1808            /* Check the parameters */
   1809            assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
   1810            
   1811            /* Clear the selected ETHERNET DMA FLAG */
   1812            ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
   1813          }
   1814          
   1815          /**
   1816            * @brief  Enables or disables the specified ETHERNET DMA interrupts.
   1817            * @param  ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be
   1818            *   enabled or disabled.
   1819            *   This parameter can be any combination of the following values:
   1820            *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
   1821            *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
   1822            *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
   1823            *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
   1824            *     @arg ETH_DMA_IT_ET  : Early transmit interrupt 
   1825            *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
   1826            *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
   1827            *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
   1828            *     @arg ETH_DMA_IT_R   : Receive interrupt 
   1829            *     @arg ETH_DMA_IT_TU  : Underflow interrupt 
   1830            *     @arg ETH_DMA_IT_RO  : Overflow interrupt 
   1831            *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
   1832            *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
   1833            *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
   1834            *     @arg ETH_DMA_IT_T   : Transmit interrupt
   1835            * @param  NewState: new state of the specified ETHERNET DMA interrupts.
   1836            *   This parameter can be: ENABLE or DISABLE.
   1837            * @retval None
   1838            */
   1839          void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
   1840          {
   1841            /* Check the parameters */
   1842            assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
   1843            assert_param(IS_FUNCTIONAL_STATE(NewState));  
   1844            
   1845            if (NewState != DISABLE)
   1846            {
   1847              /* Enable the selected ETHERNET DMA interrupts */
   1848              ETH->DMAIER |= ETH_DMA_IT;
   1849            }
   1850            else
   1851            {
   1852              /* Disable the selected ETHERNET DMA interrupts */
   1853              ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
   1854            }
   1855          }
   1856          
   1857          /**
   1858            * @brief  Checks whether the specified ETHERNET DMA interrupt has occurred or not.
   1859            * @param  ETH_DMA_IT: specifies the interrupt source to check.
   1860            *   This parameter can be one of the following values:
   1861            *     @arg ETH_DMA_IT_TST : Time-stamp trigger interrupt
   1862            *     @arg ETH_DMA_IT_PMT : PMT interrupt 
   1863            *     @arg ETH_DMA_IT_MMC : MMC interrupt
   1864            *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
   1865            *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
   1866            *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
   1867            *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
   1868            *     @arg ETH_DMA_IT_ET  : Early transmit interrupt 
   1869            *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
   1870            *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
   1871            *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
   1872            *     @arg ETH_DMA_IT_R   : Receive interrupt 
   1873            *     @arg ETH_DMA_IT_TU  : Underflow interrupt 
   1874            *     @arg ETH_DMA_IT_RO  : Overflow interrupt 
   1875            *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
   1876            *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
   1877            *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
   1878            *     @arg ETH_DMA_IT_T   : Transmit interrupt 
   1879            * @retval The new state of ETH_DMA_IT (SET or RESET).
   1880            */
   1881          ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
   1882          {  
   1883            ITStatus bitstatus = RESET;
   1884            /* Check the parameters */
   1885            assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
   1886            if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
   1887            {
   1888              bitstatus = SET;
   1889            }
   1890            else
   1891            {
   1892              bitstatus = RESET;
   1893            }
   1894            return bitstatus;
   1895          }
   1896          
   1897          /**
   1898            * @brief  Clears the ETHERNETs DMA IT pending bit.
   1899            * @param  ETH_DMA_IT: specifies the interrupt pending bit to clear.
   1900            *   This parameter can be any combination of the following values:
   1901            *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
   1902            *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
   1903            *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
   1904            *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
   1905            *     @arg ETH_DMA_IT_ETI : Early transmit interrupt 
   1906            *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
   1907            *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
   1908            *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
   1909            *     @arg ETH_DMA_IT_R   : Receive interrupt 
   1910            *     @arg ETH_DMA_IT_TU  : Transmit Underflow interrupt 
   1911            *     @arg ETH_DMA_IT_RO  : Receive Overflow interrupt 
   1912            *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
   1913            *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
   1914            *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
   1915            *     @arg ETH_DMA_IT_T   : Transmit interrupt
   1916            * @retval None
   1917            */
   1918          void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
   1919          {
   1920            /* Check the parameters */
   1921            assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
   1922            
   1923            /* Clear the selected ETHERNET DMA IT */
   1924            ETH->DMASR = (uint32_t) ETH_DMA_IT;
   1925          }
   1926          
   1927          /**
   1928            * @brief  Returns the ETHERNET DMA Transmit Process State.
   1929            * @param  None
   1930            * @retval The new ETHERNET DMA Transmit Process State:
   1931            *   This can be one of the following values:
   1932            *     - ETH_DMA_TransmitProcess_Stopped   : Stopped - Reset or Stop Tx Command issued
   1933            *     - ETH_DMA_TransmitProcess_Fetching  : Running - fetching the Tx descriptor 
   1934            *     - ETH_DMA_TransmitProcess_Waiting   : Running - waiting for status
   1935            *     - ETH_DMA_TransmitProcess_Reading   : Running - reading the data from host memory
   1936            *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Descriptor unavailable
   1937            *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
   1938            */
   1939          uint32_t ETH_GetTransmitProcessState(void)
   1940          {
   1941            return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
   1942          }
   1943          
   1944          /**
   1945            * @brief  Returns the ETHERNET DMA Receive Process State.
   1946            * @param  None
   1947            * @retval The new ETHERNET DMA Receive Process State:
   1948            *   This can be one of the following values:
   1949            *     - ETH_DMA_ReceiveProcess_Stopped   : Stopped - Reset or Stop Rx Command issued
   1950            *     - ETH_DMA_ReceiveProcess_Fetching  : Running - fetching the Rx descriptor 
   1951            *     - ETH_DMA_ReceiveProcess_Waiting   : Running - waiting for packet
   1952            *     - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Descriptor unavailable
   1953            *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
   1954            *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the receive frame into host memory  
   1955            */
   1956          uint32_t ETH_GetReceiveProcessState(void)
   1957          {
   1958            return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
   1959          }
   1960          
   1961          /**
   1962            * @brief  Clears the ETHERNET transmit FIFO.
   1963            * @param  None                
   1964            * @retval None
   1965            */
   1966          void ETH_FlushTransmitFIFO(void)
   1967          {
   1968            /* Set the Flush Transmit FIFO bit */
   1969            ETH->DMAOMR |= ETH_DMAOMR_FTF;  
   1970          }
   1971          
   1972          /**
   1973            * @brief  Checks whether the ETHERNET flush transmit FIFO bit is cleared or not.
   1974            * @param  None                
   1975            * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
   1976            */
   1977          FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
   1978          {   
   1979            FlagStatus bitstatus = RESET;
   1980            if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
   1981            {
   1982              bitstatus = SET;
   1983            }
   1984            else
   1985            {
   1986              bitstatus = RESET;
   1987            }
   1988            return bitstatus; 
   1989          }
   1990          
   1991          /**
   1992            * @brief  Enables or disables the DMA transmission.
   1993            * @param  NewState: new state of the DMA transmission.
   1994            *   This parameter can be: ENABLE or DISABLE.
   1995            * @retval None
   1996            */
   1997          void ETH_DMATransmissionCmd(FunctionalState NewState)
   1998          { 
   1999            /* Check the parameters */
   2000            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2001            
   2002            if (NewState != DISABLE)
   2003            {
   2004              /* Enable the DMA transmission */
   2005              ETH->DMAOMR |= ETH_DMAOMR_ST;  
   2006            }
   2007            else
   2008            {
   2009              /* Disable the DMA transmission */
   2010              ETH->DMAOMR &= ~ETH_DMAOMR_ST;
   2011            }
   2012          }
   2013          
   2014          /**
   2015            * @brief  Enables or disables the DMA reception.
   2016            * @param  NewState: new state of the DMA reception.
   2017            *   This parameter can be: ENABLE or DISABLE.
   2018            * @retval None
   2019            */
   2020          void ETH_DMAReceptionCmd(FunctionalState NewState)
   2021          { 
   2022            /* Check the parameters */
   2023            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2024            
   2025            if (NewState != DISABLE)
   2026            {
   2027              /* Enable the DMA reception */
   2028              ETH->DMAOMR |= ETH_DMAOMR_SR;  
   2029            }
   2030            else
   2031            {
   2032              /* Disable the DMA reception */
   2033              ETH->DMAOMR &= ~ETH_DMAOMR_SR;
   2034            }
   2035          }
   2036          
   2037          /**
   2038            * @brief  Checks whether the specified ETHERNET DMA overflow flag is set or not.
   2039            * @param  ETH_DMA_Overflow: specifies the DMA overflow flag to check.
   2040            *   This parameter can be one of the following values:
   2041            *     @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflows Counter
   2042            *     @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Buffer Unavailable Missed Frame Counter
   2043            * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET).
   2044            */
   2045          FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
   2046          {
   2047            FlagStatus bitstatus = RESET;
   2048            /* Check the parameters */
   2049            assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
   2050            
   2051            if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
   2052            {
   2053              bitstatus = SET;
   2054            }
   2055            else
   2056            {
   2057              bitstatus = RESET;
   2058            }
   2059            return bitstatus;
   2060          }
   2061          
   2062          /**
   2063            * @brief  Get the ETHERNET DMA Rx Overflow Missed Frame Counter value.
   2064            * @param  None
   2065            * @retval The value of Rx overflow Missed Frame Counter.
   2066            */
   2067          uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
   2068          {
   2069            return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
   2070          }
   2071          
   2072          /**
   2073            * @brief  Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value.
   2074            * @param  None
   2075            * @retval The value of Buffer unavailable Missed Frame Counter.
   2076            */
   2077          uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
   2078          {
   2079            return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
   2080          }
   2081          
   2082          /**
   2083            * @brief  Get the ETHERNET DMA DMACHTDR register value.
   2084            * @param  None
   2085            * @retval The value of the current Tx desc start address.
   2086            */
   2087          uint32_t ETH_GetCurrentTxDescStartAddress(void)
   2088          {
   2089            return ((uint32_t)(ETH->DMACHTDR));
   2090          }
   2091          
   2092          /**
   2093            * @brief  Get the ETHERNET DMA DMACHRDR register value.
   2094            * @param  None
   2095            * @retval The value of the current Rx desc start address.
   2096            */
   2097          uint32_t ETH_GetCurrentRxDescStartAddress(void)
   2098          {
   2099            return ((uint32_t)(ETH->DMACHRDR));
   2100          }
   2101          
   2102          /**
   2103            * @brief  Get the ETHERNET DMA DMACHTBAR register value.
   2104            * @param  None
   2105            * @retval The value of the current transmit descriptor data buffer address.
   2106            */
   2107          uint32_t ETH_GetCurrentTxBufferAddress(void)
   2108          {
   2109            return ((uint32_t)(ETH->DMACHTBAR));
   2110          }
   2111          
   2112          /**
   2113            * @brief  Get the ETHERNET DMA DMACHRBAR register value.
   2114            * @param  None
   2115            * @retval The value of the current receive descriptor data buffer address.
   2116            */
   2117          uint32_t ETH_GetCurrentRxBufferAddress(void)
   2118          {
   2119            return ((uint32_t)(ETH->DMACHRBAR));
   2120          }
   2121          
   2122          /**
   2123            * @brief  Resumes the DMA Transmission by writing to the DmaTxPollDemand register
   2124            *   (the data written could be anything). This forces  the DMA to resume transmission.
   2125            * @param  None
   2126            * @retval None.
   2127            */
   2128          void ETH_ResumeDMATransmission(void)
   2129          {
   2130            ETH->DMATPDR = 0;
   2131          }
   2132          
   2133          /**
   2134            * @brief  Resumes the DMA Transmission by writing to the DmaRxPollDemand register
   2135            *   (the data written could be anything). This forces the DMA to resume reception.
   2136            * @param  None
   2137            * @retval None.
   2138            */
   2139          void ETH_ResumeDMAReception(void)
   2140          {
   2141            ETH->DMARPDR = 0;
   2142          }
   2143          
   2144          /**
   2145            * @brief  Set the DMA Receive status watchdog timer register value
   2146            * @param  Value: DMA Receive status watchdog timer register value   
   2147            * @retval None
   2148            */
   2149          void ETH_SetReceiveWatchdogTimer(uint8_t Value)
   2150          {
   2151            /* Set the DMA Receive status watchdog timer register */
   2152            ETH->DMARSWTR = Value;
   2153          }
   2154          
   2155          /******************************************************************************/                             
   2156          /*                                PHY functions                               */
   2157          /******************************************************************************/
   2158          
   2159          /**
   2160            * @brief  Read a PHY register
   2161            * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. 
   2162            *   This parameter can be one of the following values: 0,..,31                  
   2163            * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. 
   2164            *   This parameter can be one of the following values: 
   2165            *     @arg PHY_BCR: Transceiver Basic Control Register 
   2166            *     @arg PHY_BSR: Transceiver Basic Status Register 
   2167            *     @arg PHY_SR : Transceiver Status Register    
   2168            *     @arg More PHY register could be read depending on the used PHY
   2169            * @retval ETH_ERROR: in case of timeout
   2170            *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
   2171            */
   2172          uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
   2173          {
   2174            uint32_t tmpreg = 0;     
   2175          __IO uint32_t timeout = 0;
   2176            /* Check the parameters */
   2177            assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
   2178            assert_param(IS_ETH_PHY_REG(PHYReg));
   2179            
   2180            /* Get the ETHERNET MACMIIAR value */
   2181            tmpreg = ETH->MACMIIAR;
   2182            /* Keep only the CSR Clock Range CR[2:0] bits value */
   2183            tmpreg &= ~MACMIIAR_CR_MASK;
   2184            /* Prepare the MII address register value */
   2185            tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
   2186            tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
   2187            tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
   2188            tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
   2189            /* Write the result value into the MII Address register */
   2190            ETH->MACMIIAR = tmpreg;
   2191            /* Check for the Busy flag */
   2192            do
   2193            {
   2194              timeout++;
   2195              tmpreg = ETH->MACMIIAR;
   2196            } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
   2197            /* Return ERROR in case of timeout */
   2198            if(timeout == PHY_READ_TO)
   2199            {
   2200              return (uint16_t)ETH_ERROR;
   2201            }
   2202            
   2203            /* Return data register value */
   2204            return (uint16_t)(ETH->MACMIIDR);
   2205          }
   2206          
   2207          /**
   2208            * @brief  Write to a PHY register
   2209            * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. 
   2210            *   This parameter can be one of the following values: 0,..,31
   2211            * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. 
   2212            *   This parameter can be one of the following values: 
   2213            *     @arg PHY_BCR    : Transceiver Control Register  
   2214            *     @arg More PHY register could be written depending on the used PHY
   2215            * @param  PHYValue: the value to write
   2216            * @retval ETH_ERROR: in case of timeout
   2217            *         ETH_SUCCESS: for correct write
   2218            */
   2219          uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
   2220          {
   2221            uint32_t tmpreg = 0;     
   2222            __IO uint32_t timeout = 0;
   2223            /* Check the parameters */
   2224            assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
   2225            assert_param(IS_ETH_PHY_REG(PHYReg));
   2226            
   2227            /* Get the ETHERNET MACMIIAR value */
   2228            tmpreg = ETH->MACMIIAR;
   2229            /* Keep only the CSR Clock Range CR[2:0] bits value */
   2230            tmpreg &= ~MACMIIAR_CR_MASK;
   2231            /* Prepare the MII register address value */
   2232            tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
   2233            tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
   2234            tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
   2235            tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
   2236            /* Give the value to the MII data register */
   2237            ETH->MACMIIDR = PHYValue;
   2238            /* Write the result value into the MII Address register */
   2239            ETH->MACMIIAR = tmpreg;
   2240            /* Check for the Busy flag */
   2241            do
   2242            {
   2243              timeout++;
   2244              tmpreg = ETH->MACMIIAR;
   2245            } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
   2246            /* Return ERROR in case of timeout */
   2247            if(timeout == PHY_WRITE_TO)
   2248            {
   2249              return ETH_ERROR;
   2250            }
   2251            
   2252            /* Return SUCCESS */
   2253            return ETH_SUCCESS;  
   2254          }
   2255          
   2256          /**
   2257            * @brief  Enables or disables the PHY loopBack mode.
   2258            * @Note: Don't be confused with ETH_MACLoopBackCmd function which enables internal
   2259            *  loopback at MII level
   2260            * @param  PHYAddress: PHY device address, is the index of one of supported 32 PHY devices.                   
   2261            * @param  NewState: new state of the PHY loopBack mode.
   2262            *   This parameter can be: ENABLE or DISABLE.    
   2263            * @retval ETH_ERROR: in case of bad PHY configuration
   2264            *         ETH_SUCCESS: for correct PHY configuration
   2265            */
   2266          uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
   2267          {
   2268            uint16_t tmpreg = 0;
   2269            /* Check the parameters */
   2270            assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
   2271            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2272              
   2273            /* Get the PHY configuration to update it */
   2274            tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
   2275            
   2276            if (NewState != DISABLE)
   2277            {
   2278              /* Enable the PHY loopback mode */
   2279              tmpreg |= PHY_Loopback;  
   2280            }
   2281            else
   2282            {
   2283              /* Disable the PHY loopback mode: normal mode */
   2284              tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
   2285            }
   2286            /* Update the PHY control register with the new configuration */
   2287            if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
   2288            {
   2289              return ETH_SUCCESS;
   2290            }
   2291            else
   2292            {
   2293              /* Return SUCCESS */
   2294              return ETH_ERROR; 
   2295            }   
   2296          } 
   2297          
   2298          /******************************************************************************/                             
   2299          /*                           Power Management(PMT) functions                  */
   2300          /******************************************************************************/    
   2301          /**
   2302            * @brief  Reset Wakeup frame filter register pointer.
   2303            * @param  None
   2304            * @retval None
   2305            */
   2306          void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
   2307          {  
   2308            /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
   2309            ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
   2310          }
   2311          
   2312          /**
   2313            * @brief  Populates the remote wakeup frame registers.
   2314            * @param  Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words).
   2315            * @retval None
   2316            */
   2317          void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
   2318          {
   2319            uint32_t i = 0;
   2320            
   2321            /* Fill Remote Wake-up Frame Filter register with Buffer data */
   2322            for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
   2323            {
   2324              /* Write each time to the same register */ 
   2325              ETH->MACRWUFFR = Buffer[i];
   2326            }
   2327          }
   2328          
   2329          /**
   2330            * @brief  Enables or disables any unicast packet filtered by the MAC address
   2331            *   recognition to be a wake-up frame.
   2332            * @param  NewState: new state of the MAC Global Unicast Wake-Up.
   2333            *   This parameter can be: ENABLE or DISABLE.
   2334            * @retval None
   2335            */
   2336          void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
   2337          { 
   2338            /* Check the parameters */
   2339            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2340            
   2341            if (NewState != DISABLE)
   2342            {
   2343              /* Enable the MAC Global Unicast Wake-Up */
   2344              ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
   2345            }
   2346            else
   2347            {
   2348              /* Disable the MAC Global Unicast Wake-Up */ 
   2349              ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
   2350            }
   2351          }
   2352          
   2353          /**
   2354            * @brief  Checks whether the specified ETHERNET PMT flag is set or not.
   2355            * @param  ETH_PMT_FLAG: specifies the flag to check.
   2356            *   This parameter can be one of the following values:
   2357            *     @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Pointer Reset 
   2358            *     @arg ETH_PMT_FLAG_WUFR    : Wake-Up Frame Received 
   2359            *     @arg ETH_PMT_FLAG_MPR     : Magic Packet Received
   2360            * @retval The new state of ETHERNET PMT Flag (SET or RESET).
   2361            */
   2362          FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
   2363          {
   2364            FlagStatus bitstatus = RESET;
   2365            /* Check the parameters */
   2366            assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
   2367            
   2368            if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
   2369            {
   2370              bitstatus = SET;
   2371            }
   2372            else
   2373            {
   2374              bitstatus = RESET;
   2375            }
   2376            return bitstatus;
   2377          }
   2378          
   2379          /**
   2380            * @brief  Enables or disables the MAC Wake-Up Frame Detection.
   2381            * @param  NewState: new state of the MAC Wake-Up Frame Detection.
   2382            *   This parameter can be: ENABLE or DISABLE.
   2383            * @retval None
   2384            */
   2385          void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
   2386          { 
   2387            /* Check the parameters */
   2388            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2389            
   2390            if (NewState != DISABLE)
   2391            {
   2392              /* Enable the MAC Wake-Up Frame Detection */
   2393              ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
   2394            }
   2395            else
   2396            {
   2397              /* Disable the MAC Wake-Up Frame Detection */ 
   2398              ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
   2399            }
   2400          }
   2401          
   2402          /**
   2403            * @brief  Enables or disables the MAC Magic Packet Detection.
   2404            * @param  NewState: new state of the MAC Magic Packet Detection.
   2405            *   This parameter can be: ENABLE or DISABLE.
   2406            * @retval None
   2407            */
   2408          void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
   2409          { 
   2410            /* Check the parameters */
   2411            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2412            
   2413            if (NewState != DISABLE)
   2414            {
   2415              /* Enable the MAC Magic Packet Detection */
   2416              ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
   2417            }
   2418            else
   2419            {
   2420              /* Disable the MAC Magic Packet Detection */ 
   2421              ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
   2422            }
   2423          }
   2424          
   2425          /**
   2426            * @brief  Enables or disables the MAC Power Down.
   2427            * @param  NewState: new state of the MAC Power Down.
   2428            *   This parameter can be: ENABLE or DISABLE.
   2429            * @retval None
   2430            */
   2431          void ETH_PowerDownCmd(FunctionalState NewState)
   2432          { 
   2433            /* Check the parameters */
   2434            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2435            
   2436            if (NewState != DISABLE)
   2437            {
   2438              /* Enable the MAC Power Down */
   2439              /* This puts the MAC in power down mode */
   2440              ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
   2441            }
   2442            else
   2443            {
   2444              /* Disable the MAC Power Down */ 
   2445              ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
   2446            }
   2447          } 
   2448          
   2449          /******************************************************************************/                             
   2450          /*                              MMC functions                                 */
   2451          /******************************************************************************/                            
   2452          /**
   2453            * @brief  Preset and Initialize the MMC counters to almost-full value: 0xFFFF_FFF0 (full - 16)   
   2454            * @param  None
   2455            * @retval None
   2456            */
   2457          void ETH_MMCCounterFullPreset(void)
   2458          {
   2459            /* Preset and Initialize the MMC counters to almost-full value */
   2460            ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
   2461          }
   2462          
   2463          /**
   2464            * @brief  Preset and Initialize the MMC counters to almost-hal value: 0x7FFF_FFF0 (half - 16). 
   2465            * @param  None
   2466            * @retval None
   2467            */
   2468          void ETH_MMCCounterHalfPreset(void)
   2469          {
   2470            /* Preset the MMC counters to almost-full value */
   2471            ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
   2472            /* Initialize the MMC counters to almost-half value */
   2473            ETH->MMCCR |= ETH_MMCCR_MCP;
   2474          }
   2475          
   2476           /**
   2477            * @brief  Enables or disables the MMC Counter Freeze.
   2478            * @param  NewState: new state of the MMC Counter Freeze.
   2479            *   This parameter can be: ENABLE or DISABLE.
   2480            * @retval None
   2481            */
   2482          void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
   2483          {
   2484            /* Check the parameters */
   2485            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2486            
   2487            if (NewState != DISABLE)
   2488            {
   2489              /* Enable the MMC Counter Freeze */
   2490              ETH->MMCCR |= ETH_MMCCR_MCF;
   2491            }
   2492            else
   2493            {
   2494              /* Disable the MMC Counter Freeze */
   2495              ETH->MMCCR &= ~ETH_MMCCR_MCF;
   2496            }
   2497          }
   2498          
   2499          /**
   2500            * @brief  Enables or disables the MMC Reset On Read.
   2501            * @param  NewState: new state of the MMC Reset On Read.
   2502            *   This parameter can be: ENABLE or DISABLE.
   2503            * @retval None
   2504            */
   2505          void ETH_MMCResetOnReadCmd(FunctionalState NewState)
   2506          {
   2507            /* Check the parameters */
   2508            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2509            
   2510            if (NewState != DISABLE)
   2511            {
   2512              /* Enable the MMC Counter reset on read */
   2513              ETH->MMCCR |= ETH_MMCCR_ROR; 
   2514            }
   2515            else
   2516            {
   2517              /* Disable the MMC Counter reset on read */
   2518              ETH->MMCCR &= ~ETH_MMCCR_ROR;
   2519            }
   2520          }
   2521          
   2522          /**
   2523            * @brief  Enables or disables the MMC Counter Stop Rollover.
   2524            * @param  NewState: new state of the MMC Counter Stop Rollover.
   2525            *   This parameter can be: ENABLE or DISABLE.
   2526            * @retval None
   2527            */
   2528          void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
   2529          {
   2530            /* Check the parameters */
   2531            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2532            
   2533            if (NewState != DISABLE)
   2534            {
   2535              /* Disable the MMC Counter Stop Rollover  */
   2536              ETH->MMCCR &= ~ETH_MMCCR_CSR;
   2537            }
   2538            else
   2539            {
   2540              /* Enable the MMC Counter Stop Rollover */
   2541              ETH->MMCCR |= ETH_MMCCR_CSR; 
   2542            }
   2543          }
   2544          
   2545          /**
   2546            * @brief  Resets the MMC Counters.
   2547            * @param  None
   2548            * @retval None
   2549            */
   2550          void ETH_MMCCountersReset(void)
   2551          {
   2552            /* Resets the MMC Counters */
   2553            ETH->MMCCR |= ETH_MMCCR_CR; 
   2554          }
   2555          
   2556          /**
   2557            * @brief  Enables or disables the specified ETHERNET MMC interrupts.
   2558            * @param  ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled.
   2559            *   This parameter can be any combination of Tx interrupt or 
   2560            *   any combination of Rx interrupt (but not both)of the following values: 
   2561            *     @arg ETH_MMC_IT_TGF   : When Tx good frame counter reaches half the maximum value 
   2562            *     @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value 
   2563            *     @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value 
   2564            *     @arg ETH_MMC_IT_RGUF  : When Rx good unicast frames counter reaches half the maximum value  
   2565            *     @arg ETH_MMC_IT_RFAE  : When Rx alignment error counter reaches half the maximum value 
   2566            *     @arg ETH_MMC_IT_RFCE  : When Rx crc error counter reaches half the maximum value
   2567            * @param  NewState: new state of the specified ETHERNET MMC interrupts.
   2568            *   This parameter can be: ENABLE or DISABLE.
   2569            * @retval None
   2570            */
   2571          void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
   2572          { 
   2573            /* Check the parameters */
   2574            assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
   2575            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2576             
   2577            if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
   2578            {
   2579              /* Remove Register mak from IT */
   2580              ETH_MMC_IT &= 0xEFFFFFFF;
   2581            
   2582              /* ETHERNET MMC Rx interrupts selected */
   2583              if (NewState != DISABLE)
   2584              {
   2585                /* Enable the selected ETHERNET MMC interrupts */
   2586                ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
   2587              }
   2588              else
   2589              {
   2590                /* Disable the selected ETHERNET MMC interrupts */
   2591                ETH->MMCRIMR |= ETH_MMC_IT;    
   2592              }
   2593            }
   2594            else
   2595            {
   2596              /* ETHERNET MMC Tx interrupts selected */
   2597              if (NewState != DISABLE)
   2598              {
   2599                /* Enable the selected ETHERNET MMC interrupts */
   2600                ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
   2601              }
   2602              else
   2603              {
   2604                /* Disable the selected ETHERNET MMC interrupts */
   2605                ETH->MMCTIMR |= ETH_MMC_IT;    
   2606              }  
   2607            }
   2608          }
   2609          
   2610          /**
   2611            * @brief  Checks whether the specified ETHERNET MMC IT is set or not.
   2612            * @param  ETH_MMC_IT: specifies the ETHERNET MMC interrupt.
   2613            *   This parameter can be one of the following values:
   2614            *     @arg ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value 
   2615            *     @arg ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value 
   2616            *     @arg ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value 
   2617            *     @arg ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value  
   2618            *     @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value 
   2619            *     @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value 
   2620            * @retval The value of ETHERNET MMC IT (SET or RESET).
   2621            */
   2622          ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
   2623          {
   2624            ITStatus bitstatus = RESET;
   2625            /* Check the parameters */
   2626            assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
   2627            
   2628            if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
   2629            {
   2630              /* ETHERNET MMC Rx interrupts selected */
   2631              /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
   2632              if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
   2633              {
   2634                bitstatus = SET;
   2635              }
   2636              else
   2637              {
   2638                bitstatus = RESET;
   2639              }
   2640            }
   2641            else
   2642            {
   2643              /* ETHERNET MMC Tx interrupts selected */
   2644              /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
   2645              if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
   2646              {
   2647                bitstatus = SET;
   2648              }
   2649              else
   2650              {
   2651                bitstatus = RESET;
   2652              }  
   2653            }    
   2654              
   2655            return bitstatus;
   2656          }
   2657          
   2658          /**
   2659            * @brief  Get the specified ETHERNET MMC register value.
   2660            * @param  ETH_MMCReg: specifies the ETHERNET MMC register.
   2661            *   This parameter can be one of the following values:
   2662            *     @arg ETH_MMCCR      : MMC CR register 
   2663            *     @arg ETH_MMCRIR     : MMC RIR register 
   2664            *     @arg ETH_MMCTIR     : MMC TIR register 
   2665            *     @arg ETH_MMCRIMR    : MMC RIMR register 
   2666            *     @arg ETH_MMCTIMR    : MMC TIMR register 
   2667            *     @arg ETH_MMCTGFSCCR : MMC TGFSCCR register 
   2668            *     @arg ETH_MMCTGFMSCCR: MMC TGFMSCCR register  
   2669            *     @arg ETH_MMCTGFCR   : MMC TGFCR register
   2670            *     @arg ETH_MMCRFCECR  : MMC RFCECR register 
   2671            *     @arg ETH_MMCRFAECR  : MMC RFAECR register 
   2672            *     @arg ETH_MMCRGUFCR  : MMC RGUFCRregister 
   2673            * @retval The value of ETHERNET MMC Register value.
   2674            */
   2675          uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
   2676          {
   2677            /* Check the parameters */
   2678            assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
   2679            
   2680            /* Return the selected register value */
   2681            return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
   2682          }
   2683          
   2684          
   2685                                                             
   2686          /**
   2687            * @}
   2688            */
   2689          
   2690          /**
   2691            * @}
   2692            */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ETH_BackPressureActivationCmd
       0   ETH_CheckFrameReceived
       0   ETH_DMAClearFlag
       0   ETH_DMAClearITPendingBit
       0   ETH_DMAITConfig
       0   ETH_DMAReceptionCmd
      12   ETH_DMARxDescChainInit
       0   ETH_DMARxDescReceiveITConfig
       0   ETH_DMATransmissionCmd
       4   ETH_DMATxDescBufferSizeConfig
       0   ETH_DMATxDescCRCCmd
       8   ETH_DMATxDescChainInit
       0   ETH_DMATxDescChecksumInsertionConfig
       0   ETH_DMATxDescFrameSegmentConfig
       0   ETH_DMATxDescSecondAddressChainedCmd
       0   ETH_DMATxDescShortFramePaddingCmd
       0   ETH_DMATxDescTransmitITConfig
       8   ETH_DeInit
         8   -> RCC_AHB1PeriphResetCmd
       8   ETH_Delay
       0   ETH_EnhancedDescriptorCmd
       0   ETH_FlushTransmitFIFO
       0   ETH_GetBufferUnavailableMissedFrameCounter
       0   ETH_GetCurrentRxBufferAddress
       0   ETH_GetCurrentRxDescStartAddress
       0   ETH_GetCurrentTxBufferAddress
       0   ETH_GetCurrentTxDescStartAddress
       0   ETH_GetDMAFlagStatus
       0   ETH_GetDMAITStatus
       0   ETH_GetDMAOverflowStatus
       0   ETH_GetDMAPTPRxDescExtendedFlagStatus
       0   ETH_GetDMARxDescBufferSize
       0   ETH_GetDMARxDescFlagStatus
       0   ETH_GetDMARxDescFrameLength
       0   ETH_GetDMATxDescCollisionCount
       0   ETH_GetDMATxDescFlagStatus
       0   ETH_GetFlowControlBusyStatus
       0   ETH_GetFlushTransmitFIFOStatus
       0   ETH_GetMACAddress
       0   ETH_GetMACFlagStatus
       0   ETH_GetMACITStatus
       0   ETH_GetMMCITStatus
       0   ETH_GetMMCRegister
       0   ETH_GetPMTFlagStatus
       0   ETH_GetReceiveProcessState
       0   ETH_GetRxOverflowMissedFrameCounter
      16   ETH_GetRxPktSize
        16   -> ETH_GetDMARxDescFrameLength
       0   ETH_GetSoftwareResetStatus
       0   ETH_GetTransmitProcessState
      20   ETH_Get_Received_Frame
      20   ETH_Get_Received_Frame_interrupt
       0   ETH_GlobalUnicastWakeUpCmd
      48   ETH_Init
        48   -> ETH_Delay
        48   -> ETH_ReadPHYRegister
        48   -> ETH_WritePHYRegister
        48   -> RCC_GetClocksFreq
       0   ETH_InitiatePauseControlFrame
       4   ETH_MACAddressConfig
       0   ETH_MACAddressFilterConfig
       0   ETH_MACAddressMaskBytesFilterConfig
       0   ETH_MACAddressPerfectFilterCmd
       0   ETH_MACITConfig
       0   ETH_MACReceptionCmd
       0   ETH_MACTransmissionCmd
       0   ETH_MMCCounterFreezeCmd
       0   ETH_MMCCounterFullPreset
       0   ETH_MMCCounterHalfPreset
       0   ETH_MMCCounterRolloverCmd
       0   ETH_MMCCountersReset
       0   ETH_MMCITConfig
       0   ETH_MMCResetOnReadCmd
       0   ETH_MagicPacketDetectionCmd
      16   ETH_PHYLoopBackCmd
        16   -> ETH_ReadPHYRegister
        16   -> ETH_WritePHYRegister
       0   ETH_PowerDownCmd
      12   ETH_Prepare_Transmit_Descriptors
       8   ETH_ReadPHYRegister
       0   ETH_ResetWakeUpFrameFilterRegisterPointer
       0   ETH_ResumeDMAReception
       0   ETH_ResumeDMATransmission
       0   ETH_SetDMARxDescOwnBit
       0   ETH_SetDMATxDescOwnBit
       0   ETH_SetReceiveWatchdogTimer
       0   ETH_SetWakeUpFrameFilterRegister
       0   ETH_SoftwareReset
       8   ETH_Start
         8   -> ETH_DMAReceptionCmd
         8   -> ETH_DMATransmissionCmd
         8   -> ETH_FlushTransmitFIFO
         8   -> ETH_MACReceptionCmd
         8   -> ETH_MACTransmissionCmd
       0   ETH_StructInit
       0   ETH_WakeUpFrameDetectionCmd
      12   ETH_WritePHYRegister


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_2
       4  ??DataTable43_3
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable51
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable54
       4  ??DataTable54_1
       4  ??DataTable54_2
       4  ??DataTable59
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable61_10
       4  ??DataTable61_11
       4  ??DataTable61_12
       4  ??DataTable61_13
       4  ??DataTable61_14
       4  ??DataTable61_15
       4  ??DataTable61_16
       4  ??DataTable61_17
       4  ??DataTable61_18
       4  ??DataTable61_19
       4  ??DataTable61_2
       4  ??DataTable61_20
       4  ??DataTable61_21
       4  ??DataTable61_22
       4  ??DataTable61_23
       4  ??DataTable61_24
       4  ??DataTable61_25
       4  ??DataTable61_26
       4  ??DataTable61_27
       4  ??DataTable61_28
       4  ??DataTable61_29
       4  ??DataTable61_3
       4  ??DataTable61_4
       4  ??DataTable61_5
       4  ??DataTable61_6
       4  ??DataTable61_7
       4  ??DataTable61_8
       4  ??DataTable61_9
      12  ?_0
      12  ?_1
       4  DMARxDescToGet
     128  DMARxDscrTab
       4  DMATxDescToSet
     128  DMATxDscrTab
       4  DMA_RX_FRAME_infos
      42  ETH_BackPressureActivationCmd
     218  ETH_CheckFrameReceived
       8  ETH_DMAClearFlag
       8  ETH_DMAClearITPendingBit
      38  ETH_DMAITConfig
      34  ETH_DMAReceptionCmd
      88  ETH_DMARxDescChainInit
      26  ETH_DMARxDescReceiveITConfig
      34  ETH_DMATransmissionCmd
      16  ETH_DMATxDescBufferSizeConfig
      26  ETH_DMATxDescCRCCmd
      72  ETH_DMATxDescChainInit
       8  ETH_DMATxDescChecksumInsertionConfig
       8  ETH_DMATxDescFrameSegmentConfig
      26  ETH_DMATxDescSecondAddressChainedCmd
      26  ETH_DMATxDescShortFramePaddingCmd
      26  ETH_DMATxDescTransmitITConfig
      24  ETH_DeInit
      30  ETH_Delay
      42  ETH_EnhancedDescriptorCmd
      14  ETH_FlushTransmitFIFO
      10  ETH_GetBufferUnavailableMissedFrameCounter
       8  ETH_GetCurrentRxBufferAddress
       8  ETH_GetCurrentRxDescStartAddress
       8  ETH_GetCurrentTxBufferAddress
       8  ETH_GetCurrentTxDescStartAddress
      28  ETH_GetDMAFlagStatus
      28  ETH_GetDMAITStatus
      28  ETH_GetDMAOverflowStatus
      24  ETH_GetDMAPTPRxDescExtendedFlagStatus
      20  ETH_GetDMARxDescBufferSize
      24  ETH_GetDMARxDescFlagStatus
       8  ETH_GetDMARxDescFrameLength
       8  ETH_GetDMATxDescCollisionCount
      24  ETH_GetDMATxDescFlagStatus
      26  ETH_GetFlowControlBusyStatus
      24  ETH_GetFlushTransmitFIFOStatus
      38  ETH_GetMACAddress
      28  ETH_GetMACFlagStatus
      28  ETH_GetMACITStatus
      66  ETH_GetMMCITStatus
       6  ETH_GetMMCRegister
      26  ETH_GetPMTFlagStatus
      12  ETH_GetReceiveProcessState
      12  ETH_GetRxOverflowMissedFrameCounter
      36  ETH_GetRxPktSize
      26  ETH_GetSoftwareResetStatus
      12  ETH_GetTransmitProcessState
     106  ETH_Get_Received_Frame
     328  ETH_Get_Received_Frame_interrupt
      34  ETH_GlobalUnicastWakeUpCmd
     704  ETH_Init
      18  ETH_InitiatePauseControlFrame
      50  ETH_MACAddressConfig
      40  ETH_MACAddressFilterConfig
      32  ETH_MACAddressMaskBytesFilterConfig
      42  ETH_MACAddressPerfectFilterCmd
      38  ETH_MACITConfig
      42  ETH_MACReceptionCmd
      42  ETH_MACTransmissionCmd
      34  ETH_MMCCounterFreezeCmd
      14  ETH_MMCCounterFullPreset
      26  ETH_MMCCounterHalfPreset
      34  ETH_MMCCounterRolloverCmd
      14  ETH_MMCCountersReset
      68  ETH_MMCITConfig
      34  ETH_MMCResetOnReadCmd
      34  ETH_MagicPacketDetectionCmd
      64  ETH_PHYLoopBackCmd
      34  ETH_PowerDownCmd
     280  ETH_Prepare_Transmit_Descriptors
     106  ETH_ReadPHYRegister
      14  ETH_ResetWakeUpFrameFilterRegisterPointer
      10  ETH_ResumeDMAReception
      10  ETH_ResumeDMATransmission
      10  ETH_SetDMARxDescOwnBit
      10  ETH_SetDMATxDescOwnBit
      10  ETH_SetReceiveWatchdogTimer
      24  ETH_SetWakeUpFrameFilterRegister
      18  ETH_SoftwareReset
      32  ETH_Start
     238  ETH_StructInit
      34  ETH_WakeUpFrameDetectionCmd
     100  ETH_WritePHYRegister
       4  Frame_Rx_index
      12  RX_Frame_Descriptor
    6096  Rx_Buff
    6096  Tx_Buff

 
 12 476 bytes in section .bss
     24 bytes in section .rodata
  4 304 bytes in section .text
 
  4 304 bytes of CODE  memory
     24 bytes of CONST memory
 12 476 bytes of DATA  memory

Errors: none
Warnings: none
